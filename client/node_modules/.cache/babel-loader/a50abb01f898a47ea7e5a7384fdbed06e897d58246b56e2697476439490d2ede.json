{"ast":null,"code":"import { GraphQLError as r, print as e, parse as t, Kind as a } from \"@0no-co/graphql.web\";\nimport { onEnd as o, filter as n, fromAsyncIterable as s } from \"wonka\";\nvar rehydrateGraphQlError = e => {\n  if (e && e.message && (e.extensions || \"GraphQLError\" === e.name)) {\n    return e;\n  } else if (\"object\" == typeof e && e.message) {\n    return new r(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});\n  } else {\n    return new r(e);\n  }\n};\nclass CombinedError extends Error {\n  constructor(r) {\n    var e = (r.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((r, e) => {\n      var t = \"\";\n      if (r) {\n        return `[Network] ${r.message}`;\n      }\n      if (e) {\n        for (var a of e) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(r.networkError, e);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = e;\n    this.networkError = r.networkError;\n    this.response = r.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\nvar phash = (r, e) => {\n  var t = 0 | (e || 5381);\n  for (var a = 0, o = 0 | r.length; a < o; a++) {\n    t = (t << 5) + t + r.charCodeAt(a);\n  }\n  return t;\n};\nvar i = new Set();\nvar f = new WeakMap();\nvar stringify = r => {\n  if (null === r || i.has(r)) {\n    return \"null\";\n  } else if (\"object\" != typeof r) {\n    return JSON.stringify(r) || \"\";\n  } else if (r.toJSON) {\n    return stringify(r.toJSON());\n  } else if (Array.isArray(r)) {\n    var e = \"[\";\n    for (var t of r) {\n      if (e.length > 1) {\n        e += \",\";\n      }\n      e += stringify(t) || \"null\";\n    }\n    return e += \"]\";\n  } else if (v !== NoopConstructor && r instanceof v || l !== NoopConstructor && r instanceof l) {\n    return \"null\";\n  }\n  var a = Object.keys(r).sort();\n  if (!a.length && r.constructor && r.constructor !== Object) {\n    var o = f.get(r) || Math.random().toString(36).slice(2);\n    f.set(r, o);\n    return stringify({\n      __key: o\n    });\n  }\n  i.add(r);\n  var n = \"{\";\n  for (var s of a) {\n    var c = stringify(r[s]);\n    if (c) {\n      if (n.length > 1) {\n        n += \",\";\n      }\n      n += stringify(s) + \":\" + c;\n    }\n  }\n  i.delete(r);\n  return n += \"}\";\n};\nvar extract = (r, e, t) => {\n  if (null == t || \"object\" != typeof t || t.toJSON || i.has(t)) {} else if (Array.isArray(t)) {\n    for (var a = 0, o = t.length; a < o; a++) {\n      extract(r, `${e}.${a}`, t[a]);\n    }\n  } else if (t instanceof v || t instanceof l) {\n    r.set(e, t);\n  } else {\n    i.add(t);\n    for (var n of Object.keys(t)) {\n      extract(r, `${e}.${n}`, t[n]);\n    }\n  }\n};\nvar stringifyVariables = r => {\n  i.clear();\n  return stringify(r);\n};\nclass NoopConstructor {}\nvar v = \"undefined\" != typeof File ? File : NoopConstructor;\nvar l = \"undefined\" != typeof Blob ? Blob : NoopConstructor;\nvar c = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nvar d = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\nvar replaceOutsideStrings = (r, e) => e % 2 == 0 ? r.replace(d, \"\\n\") : r;\nvar sanitizeDocument = r => r.split(c).map(replaceOutsideStrings).join(\"\").trim();\nvar p = new Map();\nvar u = new Map();\nvar stringifyDocument = r => {\n  var t;\n  if (\"string\" == typeof r) {\n    t = sanitizeDocument(r);\n  } else if (r.loc && u.get(r.__key) === r) {\n    t = r.loc.source.body;\n  } else {\n    t = p.get(r) || sanitizeDocument(e(r));\n    p.set(r, t);\n  }\n  if (\"string\" != typeof r && !r.loc) {\n    r.loc = {\n      start: 0,\n      end: t.length,\n      source: {\n        body: t,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return t;\n};\nvar hashDocument = r => {\n  var e = phash(stringifyDocument(r));\n  if (r.definitions) {\n    var t = getOperationName(r);\n    if (t) {\n      e = phash(`\\n# ${t}`, e);\n    }\n  }\n  return e;\n};\nvar keyDocument = r => {\n  var e;\n  var a;\n  if (\"string\" == typeof r) {\n    e = hashDocument(r);\n    a = u.get(e) || t(r, {\n      noLocation: !0\n    });\n  } else {\n    e = r.__key || hashDocument(r);\n    a = u.get(e) || r;\n  }\n  if (!a.loc) {\n    stringifyDocument(a);\n  }\n  a.__key = e;\n  u.set(e, a);\n  return a;\n};\nvar createRequest = (r, e, t) => {\n  var a = e || {};\n  var o = keyDocument(r);\n  var n = stringifyVariables(a);\n  var s = o.__key;\n  if (\"{}\" !== n) {\n    s = phash(n, s);\n  }\n  return {\n    key: s,\n    query: o,\n    variables: a,\n    extensions: t\n  };\n};\nvar getOperationName = r => {\n  for (var e of r.definitions) {\n    if (e.kind === a.OPERATION_DEFINITION) {\n      return e.name ? e.name.value : void 0;\n    }\n  }\n};\nvar getOperationType = r => {\n  for (var e of r.definitions) {\n    if (e.kind === a.OPERATION_DEFINITION) {\n      return e.operation;\n    }\n  }\n};\nvar makeResult = (r, e, t) => {\n  if (!(\"data\" in e || \"errors\" in e && Array.isArray(e.errors))) {\n    throw new Error(\"No Content\");\n  }\n  var a = \"subscription\" === r.kind;\n  return {\n    operation: r,\n    data: e.data,\n    error: Array.isArray(e.errors) ? new CombinedError({\n      graphQLErrors: e.errors,\n      response: t\n    }) : void 0,\n    extensions: e.extensions ? {\n      ...e.extensions\n    } : void 0,\n    hasNext: null == e.hasNext ? a : e.hasNext,\n    stale: !1\n  };\n};\nvar deepMerge = (r, e) => {\n  if (\"object\" == typeof r && null != r) {\n    if (!r.constructor || r.constructor === Object || Array.isArray(r)) {\n      r = Array.isArray(r) ? [...r] : {\n        ...r\n      };\n      for (var t of Object.keys(e)) {\n        r[t] = deepMerge(r[t], e[t]);\n      }\n      return r;\n    }\n  }\n  return e;\n};\nvar mergeResultPatch = (r, e, t, a) => {\n  var o = r.error ? r.error.graphQLErrors : [];\n  var n = !!r.extensions || !!e.extensions;\n  var s = {\n    ...r.extensions,\n    ...e.extensions\n  };\n  var i = e.incremental;\n  if (\"path\" in e) {\n    i = [e];\n  }\n  var f = {\n    data: r.data\n  };\n  if (i) {\n    var _loop = function (r) {\n      if (Array.isArray(r.errors)) {\n        o.push(...r.errors);\n      }\n      if (r.extensions) {\n        Object.assign(s, r.extensions);\n        n = !0;\n      }\n      var e = \"data\";\n      var t = f;\n      var i = [];\n      if (r.path) {\n        i = r.path;\n      } else if (a) {\n        var v = a.find(e => e.id === r.id);\n        if (r.subPath) {\n          i = [...v.path, ...r.subPath];\n        } else {\n          i = v.path;\n        }\n      }\n      for (var l = 0, c = i.length; l < c; e = i[l++]) {\n        t = t[e] = Array.isArray(t[e]) ? [...t[e]] : {\n          ...t[e]\n        };\n      }\n      if (r.items) {\n        var d = +e >= 0 ? e : 0;\n        for (var p = 0, u = r.items.length; p < u; p++) {\n          t[d + p] = deepMerge(t[d + p], r.items[p]);\n        }\n      } else if (void 0 !== r.data) {\n        t[e] = deepMerge(t[e], r.data);\n      }\n    };\n    for (var v of i) {\n      _loop(v);\n    }\n  } else {\n    f.data = e.data || r.data;\n    o = e.errors || o;\n  }\n  return {\n    operation: r.operation,\n    data: f.data,\n    error: o.length ? new CombinedError({\n      graphQLErrors: o,\n      response: t\n    }) : void 0,\n    extensions: n ? s : void 0,\n    hasNext: null != e.hasNext ? e.hasNext : r.hasNext,\n    stale: !1\n  };\n};\nvar makeErrorResult = (r, e, t) => ({\n  operation: r,\n  data: void 0,\n  error: new CombinedError({\n    networkError: e,\n    response: t\n  }),\n  extensions: void 0,\n  hasNext: !1,\n  stale: !1\n});\nfunction makeFetchBody(r) {\n  return {\n    query: r.extensions && r.extensions.persistedQuery && !r.extensions.persistedQuery.miss ? void 0 : stringifyDocument(r.query),\n    operationName: getOperationName(r.query),\n    variables: r.variables || void 0,\n    extensions: r.extensions\n  };\n}\nvar makeFetchURL = (r, e) => {\n  var t = \"query\" === r.kind && r.context.preferGetMethod;\n  if (!t || !e) {\n    return r.context.url;\n  }\n  var a = new URL(r.context.url);\n  for (var o in e) {\n    var n = e[o];\n    if (n) {\n      a.searchParams.set(o, \"object\" == typeof n ? stringifyVariables(n) : n);\n    }\n  }\n  var s = a.toString();\n  if (s.length > 2047 && \"force\" !== t) {\n    r.context.preferGetMethod = !1;\n    return r.context.url;\n  }\n  return s;\n};\nvar serializeBody = (r, e) => {\n  if (e && !(\"query\" === r.kind && !!r.context.preferGetMethod)) {\n    var t = stringifyVariables(e);\n    var a = (r => {\n      var e = new Map();\n      if (v !== NoopConstructor || l !== NoopConstructor) {\n        i.clear();\n        extract(e, \"variables\", r);\n      }\n      return e;\n    })(e.variables);\n    if (a.size) {\n      var o = new FormData();\n      o.append(\"operations\", t);\n      o.append(\"map\", stringifyVariables({\n        ...[...a.keys()].map(r => [r])\n      }));\n      var n = 0;\n      for (var s of a.values()) {\n        o.append(\"\" + n++, s);\n      }\n      return o;\n    }\n    return t;\n  }\n};\nvar makeFetchOptions = (r, e) => {\n  var t = {\n    accept: \"subscription\" === r.kind ? \"text/event-stream, multipart/mixed\" : \"application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed\"\n  };\n  var a = (\"function\" == typeof r.context.fetchOptions ? r.context.fetchOptions() : r.context.fetchOptions) || {};\n  if (a.headers) {\n    for (var o in a.headers) {\n      t[o.toLowerCase()] = a.headers[o];\n    }\n  }\n  var n = serializeBody(r, e);\n  if (\"string\" == typeof n && !t[\"content-type\"]) {\n    t[\"content-type\"] = \"application/json\";\n  }\n  return {\n    ...a,\n    method: n ? \"POST\" : \"GET\",\n    body: n,\n    headers: t\n  };\n};\nvar h = \"undefined\" != typeof TextDecoder ? new TextDecoder() : null;\nvar y = /boundary=\"?([^=\";]+)\"?/i;\nvar x = /data: ?([^\\n]+)/;\nvar toString = r => \"Buffer\" === r.constructor.name ? r.toString() : h.decode(r);\nasync function* streamBody(r) {\n  if (r.body[Symbol.asyncIterator]) {\n    for await (var e of r.body) {\n      yield toString(e);\n    }\n  } else {\n    var t = r.body.getReader();\n    var a;\n    try {\n      while (!(a = await t.read()).done) {\n        yield toString(a.value);\n      }\n    } finally {\n      t.cancel();\n    }\n  }\n}\nasync function* split(r, e) {\n  var t = \"\";\n  var a;\n  for await (var o of r) {\n    t += o;\n    while ((a = t.indexOf(e)) > -1) {\n      yield t.slice(0, a);\n      t = t.slice(a + e.length);\n    }\n  }\n}\nasync function* fetchOperation(r, e, t) {\n  var a = !0;\n  var o = null;\n  var n;\n  try {\n    yield await Promise.resolve();\n    var s = (n = await (r.context.fetch || fetch)(e, t)).headers.get(\"Content-Type\") || \"\";\n    var i;\n    if (/multipart\\/mixed/i.test(s)) {\n      i = async function* parseMultipartMixed(r, e) {\n        var t = r.match(y);\n        var a = \"--\" + (t ? t[1] : \"-\");\n        var o = !0;\n        var n;\n        for await (var s of split(streamBody(e), \"\\r\\n\" + a)) {\n          if (o) {\n            o = !1;\n            var i = s.indexOf(a);\n            if (i > -1) {\n              s = s.slice(i + a.length);\n            } else {\n              continue;\n            }\n          }\n          try {\n            yield n = JSON.parse(s.slice(s.indexOf(\"\\r\\n\\r\\n\") + 4));\n          } catch (r) {\n            if (!n) {\n              throw r;\n            }\n          }\n          if (n && !1 === n.hasNext) {\n            break;\n          }\n        }\n        if (n && !1 !== n.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(s, n);\n    } else if (/text\\/event-stream/i.test(s)) {\n      i = async function* parseEventStream(r) {\n        var e;\n        for await (var t of split(streamBody(r), \"\\n\\n\")) {\n          var a = t.match(x);\n          if (a) {\n            var o = a[1];\n            try {\n              yield e = JSON.parse(o);\n            } catch (r) {\n              if (!e) {\n                throw r;\n              }\n            }\n            if (e && !1 === e.hasNext) {\n              break;\n            }\n          }\n        }\n        if (e && !1 !== e.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(n);\n    } else if (!/text\\//i.test(s)) {\n      i = async function* parseJSON(r) {\n        yield JSON.parse(await r.text());\n      }(n);\n    } else {\n      throw new Error(await n.text());\n    }\n    var f;\n    for await (var v of i) {\n      if (v.pending && !o) {\n        f = v.pending;\n      } else if (v.pending) {\n        f = [...f, ...v.pending];\n      }\n      o = o ? mergeResultPatch(o, v, n, f) : makeResult(r, v, n);\n      a = !1;\n      yield o;\n      a = !0;\n    }\n    if (!o) {\n      yield o = makeResult(r, {}, n);\n    }\n  } catch (e) {\n    if (!a) {\n      throw e;\n    }\n    yield makeErrorResult(r, n && (n.status < 200 || n.status >= 300) && n.statusText ? new Error(n.statusText) : e, n);\n  }\n}\nfunction makeFetchSource(r, e, t) {\n  var a;\n  if (\"undefined\" != typeof AbortController) {\n    t.signal = (a = new AbortController()).signal;\n  }\n  return o(() => {\n    if (a) {\n      a.abort();\n    }\n  })(n(r => !!r)(s(fetchOperation(r, e, t))));\n}\nexport { CombinedError as C, makeErrorResult as a, mergeResultPatch as b, makeResult as c, makeFetchURL as d, makeFetchOptions as e, makeFetchSource as f, getOperationType as g, createRequest as h, stringifyVariables as i, keyDocument as k, makeFetchBody as m, stringifyDocument as s };","map":{"version":3,"names":["rehydrateGraphQlError","e","message","extensions","name","r","nodes","source","positions","path","CombinedError","Error","constructor","graphQLErrors","map","t","a","networkError","response","toString","phash","o","length","charCodeAt","i","Set","f","WeakMap","stringify","has","JSON","toJSON","Array","isArray","v","NoopConstructor","l","Object","keys","sort","get","Math","random","slice","set","__key","add","n","s","c","delete","extract","stringifyVariables","clear","File","Blob","d","replaceOutsideStrings","replace","sanitizeDocument","split","join","trim","p","Map","u","stringifyDocument","loc","body","start","end","locationOffset","line","column","hashDocument","definitions","getOperationName","keyDocument","noLocation","createRequest","key","query","variables","kind","OPERATION_DEFINITION","value","getOperationType","operation","makeResult","errors","data","error","hasNext","stale","deepMerge","mergeResultPatch","incremental","_loop","push","assign","find","id","subPath","items","makeErrorResult","makeFetchBody","persistedQuery","miss","operationName","makeFetchURL","context","preferGetMethod","url","URL","searchParams","serializeBody","size","FormData","append","values","makeFetchOptions","accept","fetchOptions","headers","toLowerCase","method","h","TextDecoder","y","x","decode","streamBody","Symbol","asyncIterator","getReader","read","done","cancel","indexOf","fetchOperation","Promise","resolve","fetch","test","parseMultipartMixed","match","parse","parseEventStream","parseJSON","text","pending","status","statusText","makeFetchSource","AbortController","signal","abort"],"sources":["C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\error.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\hash.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\variables.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\request.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\result.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\internal\\fetchOptions.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\internal\\fetchSource.ts"],"sourcesContent":["import { GraphQLError } from '@0no-co/graphql.web';\nimport type { ErrorLike } from '../types';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr) return `[Network] ${networkErr.message}`;\n  if (graphQlErrs) {\n    for (const err of graphQlErrs) {\n      if (error) error += '\\n';\n      error += `[GraphQL] ${err.message}`;\n    }\n  }\n  return error;\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (\n    error &&\n    error.message &&\n    (error.extensions || error.name === 'GraphQLError')\n  ) {\n    return error;\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return new GraphQLError(error as any);\n  }\n};\n\n/** An abstracted `Error` that provides either a `networkError` or `graphQLErrors`.\n *\n * @remarks\n * During a GraphQL request, either the request can fail entirely, causing a network error,\n * or the GraphQL execution or fields can fail, which will cause an {@link ExecutionResult}\n * to contain an array of GraphQL errors.\n *\n * The `CombinedError` abstracts and normalizes both failure cases. When {@link OperationResult.error}\n * is set to this error, the `CombinedError` abstracts all errors, making it easier to handle only\n * a subset of error cases.\n *\n * @see {@link https://urql.dev/goto/docs/basics/errors} for more information on handling\n * GraphQL errors and the `CombinedError`.\n */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n\n  /** A list of GraphQL errors rehydrated from a {@link ExecutionResult}.\n   *\n   * @remarks\n   * If an {@link ExecutionResult} received from the API contains a list of errors,\n   * the `CombinedError` will rehydrate them, normalize them to\n   * {@link GraphQLError | GraphQLErrors} and list them here.\n   * An empty list indicates that no GraphQL error has been sent by the API.\n   */\n  public graphQLErrors: GraphQLError[];\n\n  /** Set to an error, if a GraphQL request has failed outright.\n   *\n   * @remarks\n   * A GraphQL over HTTP request may fail and not reach the API. Any error that\n   * prevents a GraphQl request outright, will be considered a “network error” and\n   * set here.\n   */\n  public networkError?: Error;\n\n  /** Set to the {@link Response} object a fetch exchange received.\n   *\n   * @remarks\n   * If a built-in fetch {@link Exchange} is used in `urql`, this may\n   * be set to the {@link Response} object of the Fetch API response.\n   * However, since `urql` doesn’t assume that all users will use HTTP\n   * as the only or exclusive transport for GraphQL this property is\n   * neither typed nor guaranteed and may be re-used for other purposes\n   * by non-fetch exchanges.\n   *\n   * Hint: It can be useful to use `response.status` here, however, if\n   * you plan on relying on this being a {@link Response} in your app,\n   * which it is by default, then make sure you add some extra checks\n   * before blindly assuming so!\n   */\n  public response?: any;\n\n  constructor(input: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | ErrorLike>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (input.graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(\n      input.networkError,\n      normalizedGraphQLErrors\n    );\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = input.networkError;\n    this.response = input.response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","/** A hash value as computed by {@link phash}.\n *\n * @remarks\n * Typically `HashValue`s are used as hashes and keys of GraphQL documents,\n * variables, and combined, for GraphQL requests.\n */\nexport type HashValue = number & {\n  /** Marker to indicate that a `HashValue` may not be created by a user.\n   *\n   * @remarks\n   * `HashValue`s are created by {@link phash} and are marked as such to not mix them\n   * up with other numbers and prevent them from being created or used outside of this\n   * hashing function.\n   *\n   * @internal\n   */\n  readonly _opaque: unique symbol;\n};\n\n/** Computes a djb2 hash of the given string.\n *\n * @param x - the string to be hashed\n * @param seed - optionally a prior hash for progressive hashing\n * @returns a hash value, i.e. a number\n *\n * @remark\n * This is the hashing function used throughout `urql`, primarily to compute\n * {@link Operation.key}.\n *\n * @see {@link http://www.cse.yorku.ca/~oz/hash.html#djb2} for a further description of djb2.\n */\nexport const phash = (x: string, seed?: HashValue): HashValue => {\n  let h = (seed || 5381) | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++)\n    h = (h << 5) + h + x.charCodeAt(i);\n  return h as HashValue;\n};\n","export type FileMap = Map<string, File | Blob>;\n\nconst seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (const value of x) {\n      if (out.length > 1) out += ',';\n      out += stringify(value) || 'null';\n    }\n    out += ']';\n    return out;\n  } else if (\n    (FileConstructor !== NoopConstructor && x instanceof FileConstructor) ||\n    (BlobConstructor !== NoopConstructor && x instanceof BlobConstructor)\n  ) {\n    return 'null';\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return stringify({ __key: key });\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (const key of keys) {\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nconst extract = (map: FileMap, path: string, x: any) => {\n  if (x == null || typeof x !== 'object' || x.toJSON || seen.has(x)) {\n    /*noop*/\n  } else if (Array.isArray(x)) {\n    for (let i = 0, l = x.length; i < l; i++)\n      extract(map, `${path}.${i}`, x[i]);\n  } else if (x instanceof FileConstructor || x instanceof BlobConstructor) {\n    map.set(path, x as File | Blob);\n  } else {\n    seen.add(x);\n    for (const key of Object.keys(x)) extract(map, `${path}.${key}`, x[key]);\n  }\n};\n\n/** A stable stringifier for GraphQL variables objects.\n *\n * @param x - any JSON-like data.\n * @return A JSON string.\n *\n * @remarks\n * This utility creates a stable JSON string from any passed data,\n * and protects itself from throwing.\n *\n * The JSON string is stable insofar as objects’ keys are sorted,\n * and instances of non-plain objects are replaced with random keys\n * replacing their values, which remain stable for the objects’\n * instance.\n */\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n\nclass NoopConstructor {}\nconst FileConstructor = typeof File !== 'undefined' ? File : NoopConstructor;\nconst BlobConstructor = typeof Blob !== 'undefined' ? Blob : NoopConstructor;\n\nexport const extractFiles = (x: any): FileMap => {\n  const map: FileMap = new Map();\n  if (\n    FileConstructor !== NoopConstructor ||\n    BlobConstructor !== NoopConstructor\n  ) {\n    seen.clear();\n    extract(map, 'variables', x);\n  }\n  return map;\n};\n","import { Kind, parse, print } from '@0no-co/graphql.web';\nimport type { DocumentNode, DefinitionNode } from './graphql';\nimport type { HashValue } from './hash';\nimport { phash } from './hash';\nimport { stringifyVariables } from './variables';\n\nimport type {\n  DocumentInput,\n  TypedDocumentNode,\n  AnyVariables,\n  GraphQLRequest,\n  RequestExtensions,\n} from '../types';\n\n/** A `DocumentNode` annotated with its hashed key.\n * @internal\n */\nexport type KeyedDocumentNode = TypedDocumentNode & {\n  __key: HashValue;\n};\n\nconst SOURCE_NAME = 'gql';\nconst GRAPHQL_STRING_RE = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nconst REPLACE_CHAR_RE = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\n\nconst replaceOutsideStrings = (str: string, idx: number) =>\n  idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, '\\n') : str;\n\n/** Sanitizes a GraphQL document string by replacing comments and redundant newlines in it. */\nconst sanitizeDocument = (node: string): string =>\n  node.split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('').trim();\n\nconst prints = new Map<DocumentNode | DefinitionNode, string>();\nconst docs = new Map<HashValue, KeyedDocumentNode>();\n\n/** A cached printing function for GraphQL documents.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A normalized printed string of the passed GraphQL document.\n *\n * @remarks\n * This function accepts a GraphQL query string or {@link DocumentNode},\n * then prints and sanitizes it. The sanitizer takes care of removing\n * comments, which otherwise alter the key of the document although the\n * document is otherwise equivalent to another.\n *\n * When a {@link DocumentNode} is passed to this function, it caches its\n * output by modifying the `loc.source.body` property on the GraphQL node.\n */\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  let printed: string;\n  if (typeof node === 'string') {\n    printed = sanitizeDocument(node);\n  } else if (node.loc && docs.get((node as KeyedDocumentNode).__key) === node) {\n    printed = node.loc.source.body;\n  } else {\n    printed = prints.get(node) || sanitizeDocument(print(node));\n    prints.set(node, printed);\n  }\n\n  if (typeof node !== 'string' && !node.loc) {\n    (node as any).loc = {\n      start: 0,\n      end: printed.length,\n      source: {\n        body: printed,\n        name: SOURCE_NAME,\n        locationOffset: { line: 1, column: 1 },\n      },\n    };\n  }\n\n  return printed;\n};\n\n/** Computes the hash for a document's string using {@link stringifyDocument}'s output.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A {@link HashValue}\n *\n * @privateRemarks\n * This function adds the operation name of the document to the hash, since sometimes\n * a merged document with multiple operations may be used. Although `urql` requires a\n * `DocumentNode` to only contain a single operation, when the cached `loc.source.body`\n * of a `DocumentNode` is used, this string may still contain multiple operations and\n * the resulting hash should account for only one at a time.\n */\nconst hashDocument = (\n  node: string | DefinitionNode | DocumentNode\n): HashValue => {\n  let key = phash(stringifyDocument(node));\n  // Add the operation name to the produced hash\n  if ((node as DocumentNode).definitions) {\n    const operationName = getOperationName(node as DocumentNode);\n    if (operationName) key = phash(`\\n# ${operationName}`, key);\n  }\n  return key;\n};\n\n/** Returns a canonical version of the passed `DocumentNode` with an added hash key.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A {@link KeyedDocumentNode}\n *\n * @remarks\n * `urql` will always avoid unnecessary work, no matter whether a user passes `DocumentNode`s\n * or strings of GraphQL documents to its APIs.\n *\n * This function will return a canonical version of a {@link KeyedDocumentNode} no matter\n * which kind of input is passed, avoiding parsing or hashing of passed data as needed.\n */\nexport const keyDocument = (node: string | DocumentNode): KeyedDocumentNode => {\n  let key: HashValue;\n  let query: DocumentNode;\n  if (typeof node === 'string') {\n    key = hashDocument(node);\n    query = docs.get(key) || parse(node, { noLocation: true });\n  } else {\n    key = (node as KeyedDocumentNode).__key || hashDocument(node);\n    query = docs.get(key) || node;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\n/** Creates a `GraphQLRequest` from the passed parameters.\n *\n * @param q - A string of a document or a {@link DocumentNode}\n * @param variables - A variables object for the defined GraphQL operation.\n * @returns A {@link GraphQLRequest}\n *\n * @remarks\n * `createRequest` creates a {@link GraphQLRequest} from the passed parameters,\n * while replacing the document as needed with a canonical version of itself,\n * to avoid parsing, printing, or hashing the same input multiple times.\n *\n * If no variables are passed, canonically it'll default to an empty object,\n * which is removed from the resulting hash key.\n */\nexport const createRequest = <\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  _query: DocumentInput<Data, Variables>,\n  _variables: Variables,\n  extensions?: RequestExtensions | undefined\n): GraphQLRequest<Data, Variables> => {\n  const variables = _variables || ({} as Variables);\n  const query = keyDocument(_query);\n  const printedVars = stringifyVariables(variables);\n  let key = query.__key;\n  if (printedVars !== '{}') key = phash(printedVars, key);\n  return { key, query, variables, extensions };\n};\n\n/** Returns the name of the `DocumentNode`'s operation, if any.\n * @param query - A {@link DocumentNode}\n * @returns the operation's name contained within the document, or `undefined`\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (const node of query.definitions) {\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.name ? node.name.value : undefined;\n    }\n  }\n};\n\n/** Returns the type of the `DocumentNode`'s operation, if any.\n * @param query - A {@link DocumentNode}\n * @returns the operation's type contained within the document, or `undefined`\n */\nexport const getOperationType = (query: DocumentNode): string | undefined => {\n  for (const node of query.definitions) {\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.operation;\n    }\n  }\n};\n","import type {\n  ExecutionResult,\n  Operation,\n  OperationResult,\n  IncrementalPayload,\n} from '../types';\nimport { CombinedError } from './error';\n\n/** Converts the `ExecutionResult` received for a given `Operation` to an `OperationResult`.\n *\n * @param operation - The {@link Operation} for which the API’s result is for.\n * @param result - The GraphQL API’s {@link ExecutionResult}.\n * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).\n * @returns An {@link OperationResult}.\n *\n * @remarks\n * This utility can be used to create {@link OperationResult | OperationResults} in the shape\n * that `urql` expects and defines, and should be used rather than creating the results manually.\n *\n * @throws\n * If no data, or errors are contained within the result, or the result is instead an incremental\n * response containing a `path` property, a “No Content” error is thrown.\n *\n * @see {@link ExecutionResult} for the type definition of GraphQL API results.\n */\nexport const makeResult = (\n  operation: Operation,\n  result: ExecutionResult,\n  response?: any\n): OperationResult => {\n  if (\n    !('data' in result) &&\n    (!('errors' in result) || !Array.isArray(result.errors))\n  ) {\n    throw new Error('No Content');\n  }\n\n  const defaultHasNext = operation.kind === 'subscription';\n  return {\n    operation,\n    data: result.data,\n    error: Array.isArray(result.errors)\n      ? new CombinedError({\n          graphQLErrors: result.errors,\n          response,\n        })\n      : undefined,\n    extensions: result.extensions ? { ...result.extensions } : undefined,\n    hasNext: result.hasNext == null ? defaultHasNext : result.hasNext,\n    stale: false,\n  };\n};\n\nconst deepMerge = (target: any, source: any) => {\n  if (typeof target === 'object' && target != null) {\n    if (\n      !target.constructor ||\n      target.constructor === Object ||\n      Array.isArray(target)\n    ) {\n      target = Array.isArray(target) ? [...target] : { ...target };\n      for (const key of Object.keys(source))\n        target[key] = deepMerge(target[key], source[key]);\n      return target;\n    }\n  }\n  return source;\n};\n\n/** Merges an incrementally delivered `ExecutionResult` into a previous `OperationResult`.\n *\n * @param prevResult - The {@link OperationResult} that preceded this result.\n * @param path - The GraphQL API’s {@link ExecutionResult} that should be patching the `prevResult`.\n * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).\n * @returns A new {@link OperationResult} patched with the incremental result.\n *\n * @remarks\n * This utility should be used to merge subsequent {@link ExecutionResult | ExecutionResults} of\n * incremental responses into a prior {@link OperationResult}.\n *\n * When directives like `@defer`, `@stream`, and `@live` are used, GraphQL may deliver new\n * results that modify previous results. In these cases, it'll set a `path` property to modify\n * the result it sent last. This utility is built to handle these cases and merge these payloads\n * into existing {@link OperationResult | OperationResults}.\n *\n * @see {@link ExecutionResult} for the type definition of GraphQL API results.\n */\nexport const mergeResultPatch = (\n  prevResult: OperationResult,\n  nextResult: ExecutionResult,\n  response?: any,\n  pending?: ExecutionResult['pending']\n): OperationResult => {\n  let errors = prevResult.error ? prevResult.error.graphQLErrors : [];\n  let hasExtensions = !!prevResult.extensions || !!nextResult.extensions;\n  const extensions = { ...prevResult.extensions, ...nextResult.extensions };\n\n  let incremental = nextResult.incremental;\n\n  // NOTE: We handle the old version of the incremental delivery payloads as well\n  if ('path' in nextResult) {\n    incremental = [nextResult as IncrementalPayload];\n  }\n\n  const withData = { data: prevResult.data };\n  if (incremental) {\n    for (const patch of incremental) {\n      if (Array.isArray(patch.errors)) {\n        errors.push(...(patch.errors as any));\n      }\n\n      if (patch.extensions) {\n        Object.assign(extensions, patch.extensions);\n        hasExtensions = true;\n      }\n\n      let prop: string | number = 'data';\n      let part: Record<string, any> | Array<any> = withData;\n      let path: readonly (string | number)[] = [];\n      if (patch.path) {\n        path = patch.path;\n      } else if (pending) {\n        const res = pending.find(pendingRes => pendingRes.id === patch.id);\n        if (patch.subPath) {\n          path = [...res!.path, ...patch.subPath];\n        } else {\n          path = res!.path;\n        }\n      }\n\n      for (let i = 0, l = path.length; i < l; prop = path[i++]) {\n        part = part[prop] = Array.isArray(part[prop])\n          ? [...part[prop]]\n          : { ...part[prop] };\n      }\n\n      if (patch.items) {\n        const startIndex = +prop >= 0 ? (prop as number) : 0;\n        for (let i = 0, l = patch.items.length; i < l; i++)\n          part[startIndex + i] = deepMerge(\n            part[startIndex + i],\n            patch.items[i]\n          );\n      } else if (patch.data !== undefined) {\n        part[prop] = deepMerge(part[prop], patch.data);\n      }\n    }\n  } else {\n    withData.data = nextResult.data || prevResult.data;\n    errors = (nextResult.errors as any[]) || errors;\n  }\n\n  return {\n    operation: prevResult.operation,\n    data: withData.data,\n    error: errors.length\n      ? new CombinedError({ graphQLErrors: errors, response })\n      : undefined,\n    extensions: hasExtensions ? extensions : undefined,\n    hasNext:\n      nextResult.hasNext != null ? nextResult.hasNext : prevResult.hasNext,\n    stale: false,\n  };\n};\n\n/** Creates an `OperationResult` containing a network error for requests that encountered unexpected errors.\n *\n * @param operation - The {@link Operation} for which the API’s result is for.\n * @param error - The network-like error that prevented an API result from being delivered.\n * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).\n * @returns An {@link OperationResult} containing only a {@link CombinedError}.\n *\n * @remarks\n * This utility can be used to create {@link OperationResult | OperationResults} in the shape\n * that `urql` expects and defines, and should be used rather than creating the results manually.\n * This function should be used for when the {@link CombinedError.networkError} property is\n * populated and no GraphQL execution actually occurred.\n */\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n  hasNext: false,\n  stale: false,\n});\n","import {\n  stringifyDocument,\n  getOperationName,\n  stringifyVariables,\n  extractFiles,\n} from '../utils';\n\nimport type { AnyVariables, GraphQLRequest, Operation } from '../types';\n\n/** Abstract definition of the JSON data sent during GraphQL HTTP POST requests. */\nexport interface FetchBody {\n  query?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\n/** Creates a GraphQL over HTTP compliant JSON request body.\n * @param request - An object containing a `query` document and `variables`.\n * @returns A {@link FetchBody}\n * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.\n */\nexport function makeFetchBody<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(request: Omit<GraphQLRequest<Data, Variables>, 'key'>): FetchBody {\n  const isAPQ =\n    request.extensions &&\n    request.extensions.persistedQuery &&\n    !request.extensions.persistedQuery.miss;\n  return {\n    query: isAPQ ? undefined : stringifyDocument(request.query),\n    operationName: getOperationName(request.query),\n    variables: request.variables || undefined,\n    extensions: request.extensions,\n  };\n}\n\n/** Creates a URL that will be called for a GraphQL HTTP request.\n *\n * @param operation - An {@link Operation} for which to make the request.\n * @param body - A {@link FetchBody} which may be replaced with a URL.\n *\n * @remarks\n * Creates the URL that’ll be called as part of a GraphQL HTTP request.\n * Built-in fetch exchanges support sending GET requests, even for\n * non-persisted full requests, which this function supports by being\n * able to serialize GraphQL requests into the URL.\n */\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod =\n    operation.kind === 'query' && operation.context.preferGetMethod;\n  if (!useGETMethod || !body) return operation.context.url;\n\n  const url = new URL(operation.context.url);\n  for (const key in body) {\n    const value = body[key];\n    if (value) {\n      url.searchParams.set(\n        key,\n        typeof value === 'object' ? stringifyVariables(value) : value\n      );\n    }\n  }\n\n  const finalUrl = url.toString();\n  if (finalUrl.length > 2047 && useGETMethod !== 'force') {\n    operation.context.preferGetMethod = false;\n    return operation.context.url;\n  }\n\n  return finalUrl;\n};\n\n/** Serializes a {@link FetchBody} into a {@link RequestInit.body} format. */\nconst serializeBody = (\n  operation: Operation,\n  body?: FetchBody\n): FormData | string | undefined => {\n  const omitBody =\n    operation.kind === 'query' && !!operation.context.preferGetMethod;\n  if (body && !omitBody) {\n    const json = stringifyVariables(body);\n    const files = extractFiles(body.variables);\n    if (files.size) {\n      const form = new FormData();\n      form.append('operations', json);\n      form.append(\n        'map',\n        stringifyVariables({\n          ...[...files.keys()].map(value => [value]),\n        })\n      );\n      let index = 0;\n      for (const file of files.values()) form.append(`${index++}`, file);\n      return form;\n    }\n    return json;\n  }\n};\n\n/** Creates a `RequestInit` object for a given `Operation`.\n *\n * @param operation - An {@link Operation} for which to make the request.\n * @param body - A {@link FetchBody} which is added to the options, if the request isn’t a GET request.\n *\n * @remarks\n * Creates the fetch options {@link RequestInit} object that’ll be passed to the Fetch API\n * as part of a GraphQL over HTTP request. It automatically sets a default `Content-Type`\n * header.\n *\n * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n */\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const headers: HeadersInit = {\n    accept:\n      operation.kind === 'subscription'\n        ? 'text/event-stream, multipart/mixed'\n        : 'application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed',\n  };\n  const extraOptions =\n    (typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions) || {};\n  if (extraOptions.headers)\n    for (const key in extraOptions.headers)\n      headers[key.toLowerCase()] = extraOptions.headers[key];\n  const serializedBody = serializeBody(operation, body);\n  if (typeof serializedBody === 'string' && !headers['content-type'])\n    headers['content-type'] = 'application/json';\n  return {\n    ...extraOptions,\n    method: serializedBody ? 'POST' : 'GET',\n    body: serializedBody,\n    headers,\n  };\n};\n","/* Summary: This file handles the HTTP transport via GraphQL over HTTP\n * See: https://graphql.github.io/graphql-over-http/draft/\n *\n * `@urql/core`, by default, implements several RFC'd protocol extensions\n * on top of this. As such, this implementation supports:\n * - [Incremental Delivery](https://github.com/graphql/graphql-over-http/blob/main/rfcs/IncrementalDelivery.md)\n * - [GraphQL over SSE](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverSSE.md)\n *\n * This also supports the \"Defer Stream\" payload format.\n * See: https://github.com/graphql/graphql-wg/blob/main/rfcs/DeferStream.md\n * Implementation for this is located in `../utils/result.ts` in `mergeResultPatch`\n *\n * And; this also supports the GraphQL Multipart spec for file uploads.\n * See: https://github.com/jaydenseric/graphql-multipart-request-spec\n * Implementation for this is located in `../utils/variables.ts` in `extractFiles`,\n * and `./fetchOptions.ts` in `serializeBody`.\n *\n * And; this also supports GET requests (and hence; automatic persisted queries)\n * via the `@urql/exchange-persisted` package.\n *\n * This implementation DOES NOT support Batching.\n * See: https://github.com/graphql/graphql-over-http/blob/main/rfcs/Batching.md\n * Which is deemed out-of-scope, as it's sufficiently unnecessary given\n * modern handling of HTTP requests being in parallel.\n *\n * The implementation in this file needs to make certain accommodations for:\n * - The Web Fetch API\n * - Non-browser or polyfill Fetch APIs\n * - Node.js-like Fetch implementations (see `toString` below)\n *\n * GraphQL over SSE has a reference implementation, which supports non-HTTP/2\n * modes and is a faithful implementation of the spec.\n * See: https://github.com/enisdenjo/graphql-sse\n *\n * GraphQL Inremental Delivery (aka “GraphQL Multipart Responses”) has a\n * reference implementation, which a prior implementation of this file heavily\n * leaned on (See prior attribution comments)\n * See: https://github.com/maraisr/meros\n *\n * This file merges support for all three GraphQL over HTTP response formats\n * via async generators and Wonka’s `fromAsyncIterable`. As part of this, `streamBody`\n * and `split` are the common, cross-compatible base implementations.\n */\n\nimport type { Source } from 'wonka';\nimport { fromAsyncIterable, onEnd, filter, pipe } from 'wonka';\nimport type { Operation, OperationResult, ExecutionResult } from '../types';\nimport { makeResult, makeErrorResult, mergeResultPatch } from '../utils';\n\nconst decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;\nconst boundaryHeaderRe = /boundary=\"?([^=\";]+)\"?/i;\nconst eventStreamRe = /data: ?([^\\n]+)/;\n\ntype ChunkData = Buffer | Uint8Array;\n\n// NOTE: We're avoiding referencing the `Buffer` global here to prevent\n// auto-polyfilling in Webpack\nconst toString = (input: Buffer | ArrayBuffer): string =>\n  input.constructor.name === 'Buffer'\n    ? (input as Buffer).toString()\n    : decoder!.decode(input as ArrayBuffer);\n\nasync function* streamBody(response: Response): AsyncIterableIterator<string> {\n  if (response.body![Symbol.asyncIterator]) {\n    for await (const chunk of response.body! as any)\n      yield toString(chunk as ChunkData);\n  } else {\n    const reader = response.body!.getReader();\n    let result: ReadableStreamReadResult<ChunkData>;\n    try {\n      while (!(result = await reader.read()).done) yield toString(result.value);\n    } finally {\n      reader.cancel();\n    }\n  }\n}\n\nasync function* split(\n  chunks: AsyncIterableIterator<string>,\n  boundary: string\n): AsyncIterableIterator<string> {\n  let buffer = '';\n  let boundaryIndex: number;\n  for await (const chunk of chunks) {\n    buffer += chunk;\n    while ((boundaryIndex = buffer.indexOf(boundary)) > -1) {\n      yield buffer.slice(0, boundaryIndex);\n      buffer = buffer.slice(boundaryIndex + boundary.length);\n    }\n  }\n}\n\nasync function* parseJSON(\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  yield JSON.parse(await response.text());\n}\n\nasync function* parseEventStream(\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  let payload: any;\n  for await (const chunk of split(streamBody(response), '\\n\\n')) {\n    const match = chunk.match(eventStreamRe);\n    if (match) {\n      const chunk = match[1];\n      try {\n        yield (payload = JSON.parse(chunk));\n      } catch (error) {\n        if (!payload) throw error;\n      }\n      if (payload && payload.hasNext === false) break;\n    }\n  }\n  if (payload && payload.hasNext !== false) {\n    yield { hasNext: false };\n  }\n}\n\nasync function* parseMultipartMixed(\n  contentType: string,\n  response: Response\n): AsyncIterableIterator<ExecutionResult> {\n  const boundaryHeader = contentType.match(boundaryHeaderRe);\n  const boundary = '--' + (boundaryHeader ? boundaryHeader[1] : '-');\n  let isPreamble = true;\n  let payload: any;\n  for await (let chunk of split(streamBody(response), '\\r\\n' + boundary)) {\n    if (isPreamble) {\n      isPreamble = false;\n      const preambleIndex = chunk.indexOf(boundary);\n      if (preambleIndex > -1) {\n        chunk = chunk.slice(preambleIndex + boundary.length);\n      } else {\n        continue;\n      }\n    }\n    try {\n      yield (payload = JSON.parse(chunk.slice(chunk.indexOf('\\r\\n\\r\\n') + 4)));\n    } catch (error) {\n      if (!payload) throw error;\n    }\n    if (payload && payload.hasNext === false) break;\n  }\n  if (payload && payload.hasNext !== false) {\n    yield { hasNext: false };\n  }\n}\n\nasync function* fetchOperation(\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) {\n  let networkMode = true;\n  let result: OperationResult | null = null;\n  let response: Response | undefined;\n\n  try {\n    // Delay for a tick to give the Client a chance to cancel the request\n    // if a teardown comes in immediately\n    yield await Promise.resolve();\n\n    response = await (operation.context.fetch || fetch)(url, fetchOptions);\n    const contentType = response.headers.get('Content-Type') || '';\n\n    let results: AsyncIterable<ExecutionResult>;\n    if (/multipart\\/mixed/i.test(contentType)) {\n      results = parseMultipartMixed(contentType, response);\n    } else if (/text\\/event-stream/i.test(contentType)) {\n      results = parseEventStream(response);\n    } else if (!/text\\//i.test(contentType)) {\n      results = parseJSON(response);\n    } else {\n      throw new Error(await response.text());\n    }\n\n    let pending: ExecutionResult['pending'];\n    for await (const payload of results) {\n      if (payload.pending && !result) {\n        pending = payload.pending;\n      } else if (payload.pending) {\n        pending = [...pending!, ...payload.pending];\n      }\n      result = result\n        ? mergeResultPatch(result, payload, response, pending)\n        : makeResult(operation, payload, response);\n      networkMode = false;\n      yield result;\n      networkMode = true;\n    }\n\n    if (!result) {\n      yield (result = makeResult(operation, {}, response));\n    }\n  } catch (error: any) {\n    if (!networkMode) {\n      throw error;\n    }\n\n    yield makeErrorResult(\n      operation,\n      response &&\n        (response.status < 200 || response.status >= 300) &&\n        response.statusText\n        ? new Error(response.statusText)\n        : error,\n      response\n    );\n  }\n}\n\n/** Makes a GraphQL HTTP request to a given API by wrapping around the Fetch API.\n *\n * @param operation - The {@link Operation} that should be sent via GraphQL over HTTP.\n * @param url - The endpoint URL for the GraphQL HTTP API.\n * @param fetchOptions - The {@link RequestInit} fetch options for the request.\n * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults}.\n *\n * @remarks\n * This utility defines how all built-in fetch exchanges make GraphQL HTTP requests,\n * supporting multipart incremental responses, cancellation and other smaller\n * implementation details.\n *\n * If you’re implementing a modified fetch exchange for a GraphQL over HTTP API\n * it’s recommended you use this utility.\n *\n * Hint: This function does not use the passed `operation` to create or modify the\n * `fetchOptions` and instead expects that the options have already been created\n * using {@link makeFetchOptions} and modified as needed.\n *\n * @throws\n * If the `fetch` polyfill or globally available `fetch` function doesn’t support\n * streamed multipart responses while trying to handle a `multipart/mixed` GraphQL response,\n * the source will throw “Streaming requests unsupported”.\n * This shouldn’t happen in modern browsers and Node.js.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n */\nexport function makeFetchSource(\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Source<OperationResult> {\n  let abortController: AbortController | void;\n  if (typeof AbortController !== 'undefined') {\n    fetchOptions.signal = (abortController = new AbortController()).signal;\n  }\n  return pipe(\n    fromAsyncIterable(fetchOperation(operation, url, fetchOptions)),\n    filter((result): result is OperationResult => !!result),\n    onEnd(() => {\n      if (abortController) abortController.abort();\n    })\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}