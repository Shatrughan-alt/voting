{"ast":null,"code":"import { Kind as e } from \"@0no-co/graphql.web\";\nimport { k as r, s as t, C as n, m as a, a as o, b as s, c, d as u, e as p, f as d, g as v, h as f } from \"./urql-core-chunk.mjs\";\nexport { i as stringifyVariables } from \"./urql-core-chunk.mjs\";\nimport { toPromise as l, take as h, filter as y, subscribe as k, map as m, tap as x, merge as w, mergeMap as g, takeUntil as E, make as O, onPush as N, share as b, fromPromise as _, fromValue as q, makeSubject as D, lazy as S, onStart as P, switchMap as V, publish as R, takeWhile as A, onEnd as M } from \"wonka\";\nvar collectTypes = (e, r) => {\n  if (Array.isArray(e)) {\n    for (var t of e) {\n      collectTypes(t, r);\n    }\n  } else if (\"object\" == typeof e && null !== e) {\n    for (var n in e) {\n      if (\"__typename\" === n && \"string\" == typeof e[n]) {\n        r.add(e[n]);\n      } else {\n        collectTypes(e[n], r);\n      }\n    }\n  }\n  return r;\n};\nvar formatNode = r => {\n  if (\"definitions\" in r) {\n    var t = [];\n    for (var n of r.definitions) {\n      var a = formatNode(n);\n      t.push(a);\n    }\n    return {\n      ...r,\n      definitions: t\n    };\n  }\n  if (\"directives\" in r && r.directives && r.directives.length) {\n    var o = [];\n    var i = {};\n    for (var s of r.directives) {\n      var c = s.name.value;\n      if (\"_\" !== c[0]) {\n        o.push(s);\n      } else {\n        c = c.slice(1);\n      }\n      i[c] = s;\n    }\n    r = {\n      ...r,\n      directives: o,\n      _directives: i\n    };\n  }\n  if (\"selectionSet\" in r) {\n    var u = [];\n    var p = r.kind === e.OPERATION_DEFINITION;\n    if (r.selectionSet) {\n      for (var d of r.selectionSet.selections || []) {\n        p = p || d.kind === e.FIELD && \"__typename\" === d.name.value && !d.alias;\n        var v = formatNode(d);\n        u.push(v);\n      }\n      if (!p) {\n        u.push({\n          kind: e.FIELD,\n          name: {\n            kind: e.NAME,\n            value: \"__typename\"\n          },\n          _generated: !0\n        });\n      }\n      return {\n        ...r,\n        selectionSet: {\n          ...r.selectionSet,\n          selections: u\n        }\n      };\n    }\n  }\n  return r;\n};\nvar I = new Map();\nvar formatDocument = e => {\n  var t = r(e);\n  var n = I.get(t.__key);\n  if (!n) {\n    I.set(t.__key, n = formatNode(t));\n    Object.defineProperty(n, \"__key\", {\n      value: t.__key,\n      enumerable: !1\n    });\n  }\n  return n;\n};\nvar maskTypename = (e, r) => {\n  if (!e || \"object\" != typeof e) {\n    return e;\n  } else if (Array.isArray(e)) {\n    return e.map(e => maskTypename(e));\n  } else if (e && \"object\" == typeof e && (r || \"__typename\" in e)) {\n    var t = {};\n    for (var n in e) {\n      if (\"__typename\" === n) {\n        Object.defineProperty(t, \"__typename\", {\n          enumerable: !1,\n          value: e.__typename\n        });\n      } else {\n        t[n] = maskTypename(e[n]);\n      }\n    }\n    return t;\n  } else {\n    return e;\n  }\n};\nfunction withPromise(e) {\n  var source$ = r => e(r);\n  source$.toPromise = () => l(h(1)(y(e => !e.stale && !e.hasNext)(source$)));\n  source$.then = (e, r) => source$.toPromise().then(e, r);\n  source$.subscribe = e => k(e)(source$);\n  return source$;\n}\nfunction makeOperation(e, r, t) {\n  return {\n    ...r,\n    kind: e,\n    context: r.context ? {\n      ...r.context,\n      ...t\n    } : t || r.context\n  };\n}\nvar addMetadata = (e, r) => makeOperation(e.kind, e, {\n  meta: {\n    ...e.context.meta,\n    ...r\n  }\n});\nvar noop = () => {};\nfunction gql(n) {\n  var a = new Map();\n  var o = [];\n  var i = [];\n  var s = Array.isArray(n) ? n[0] : n || \"\";\n  for (var c = 1; c < arguments.length; c++) {\n    var u = arguments[c];\n    if (u && u.definitions) {\n      i.push(u);\n    } else {\n      s += u;\n    }\n    s += arguments[0][c];\n  }\n  i.unshift(r(s));\n  for (var p of i) {\n    for (var d of p.definitions) {\n      if (d.kind === e.FRAGMENT_DEFINITION) {\n        var v = d.name.value;\n        var f = t(d);\n        if (!a.has(v)) {\n          a.set(v, f);\n          o.push(d);\n        } else if (\"production\" !== process.env.NODE_ENV && a.get(v) !== f) {\n          console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + v + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\");\n        }\n      } else {\n        o.push(d);\n      }\n    }\n  }\n  return r({\n    kind: e.DOCUMENT,\n    definitions: o\n  });\n}\nvar shouldSkip = ({\n  kind: e\n}) => \"mutation\" !== e && \"query\" !== e;\nvar mapTypeNames = e => {\n  var r = formatDocument(e.query);\n  if (r !== e.query) {\n    var t = makeOperation(e.kind, e);\n    t.query = r;\n    return t;\n  } else {\n    return e;\n  }\n};\nvar cacheExchange = ({\n  forward: e,\n  client: r,\n  dispatchDebug: t\n}) => {\n  var n = new Map();\n  var a = new Map();\n  var isOperationCached = e => \"query\" === e.kind && \"network-only\" !== e.context.requestPolicy && (\"cache-only\" === e.context.requestPolicy || n.has(e.key));\n  return o => {\n    var i = m(e => {\n      var a = n.get(e.key);\n      \"production\" !== process.env.NODE_ENV && t({\n        operation: e,\n        ...(a ? {\n          type: \"cacheHit\",\n          message: \"The result was successfully retried from the cache\"\n        } : {\n          type: \"cacheMiss\",\n          message: \"The result could not be retrieved from the cache\"\n        }),\n        source: \"cacheExchange\"\n      });\n      var o = a;\n      if (\"production\" !== process.env.NODE_ENV) {\n        o = {\n          ...o,\n          operation: \"production\" !== process.env.NODE_ENV ? addMetadata(e, {\n            cacheOutcome: a ? \"hit\" : \"miss\"\n          }) : e\n        };\n      }\n      if (\"cache-and-network\" === e.context.requestPolicy) {\n        o.stale = !0;\n        reexecuteOperation(r, e);\n      }\n      return o;\n    })(y(e => !shouldSkip(e) && isOperationCached(e))(o));\n    var s = x(e => {\n      var {\n        operation: o\n      } = e;\n      if (!o) {\n        return;\n      }\n      var i = o.context.additionalTypenames || [];\n      if (\"subscription\" !== e.operation.kind) {\n        i = (e => [...collectTypes(e, new Set())])(e.data).concat(i);\n      }\n      if (\"mutation\" === e.operation.kind || \"subscription\" === e.operation.kind) {\n        var s = new Set();\n        \"production\" !== process.env.NODE_ENV && t({\n          type: \"cacheInvalidation\",\n          message: `The following typenames have been invalidated: ${i}`,\n          operation: o,\n          data: {\n            typenames: i,\n            response: e\n          },\n          source: \"cacheExchange\"\n        });\n        for (var c = 0; c < i.length; c++) {\n          var u = i[c];\n          var p = a.get(u);\n          if (!p) {\n            a.set(u, p = new Set());\n          }\n          for (var d of p.values()) {\n            s.add(d);\n          }\n          p.clear();\n        }\n        for (var v of s.values()) {\n          if (n.has(v)) {\n            o = n.get(v).operation;\n            n.delete(v);\n            reexecuteOperation(r, o);\n          }\n        }\n      } else if (\"query\" === o.kind && e.data) {\n        n.set(o.key, e);\n        for (var f = 0; f < i.length; f++) {\n          var l = i[f];\n          var h = a.get(l);\n          if (!h) {\n            a.set(l, h = new Set());\n          }\n          h.add(o.key);\n        }\n      }\n    })(e(y(e => \"query\" !== e.kind || \"cache-only\" !== e.context.requestPolicy)(m(e => \"production\" !== process.env.NODE_ENV ? addMetadata(e, {\n      cacheOutcome: \"miss\"\n    }) : e)(w([m(mapTypeNames)(y(e => !shouldSkip(e) && !isOperationCached(e))(o)), y(e => shouldSkip(e))(o)])))));\n    return w([i, s]);\n  };\n};\nvar reexecuteOperation = (e, r) => e.reexecuteOperation(makeOperation(r.kind, r, {\n  requestPolicy: \"network-only\"\n}));\nvar T = new Set();\nvar ssrExchange = (e = {}) => {\n  var r = !!e.staleWhileRevalidate;\n  var t = !!e.includeExtensions;\n  var a = {};\n  var o = [];\n  var invalidate = e => {\n    o.push(e.operation.key);\n    if (1 === o.length) {\n      Promise.resolve().then(() => {\n        var e;\n        while (e = o.shift()) {\n          a[e] = null;\n        }\n      });\n    }\n  };\n  var ssr = ({\n    client: o,\n    forward: i\n  }) => s => {\n    var c = e && \"boolean\" == typeof e.isClient ? !!e.isClient : !o.suspense;\n    var u = i(m(mapTypeNames)(y(e => \"teardown\" === e.kind || !a[e.key] || !!a[e.key].hasNext || \"network-only\" === e.context.requestPolicy)(s)));\n    var p = m(e => {\n      var i = ((e, r, t) => ({\n        operation: e,\n        data: r.data ? JSON.parse(r.data) : void 0,\n        extensions: t && r.extensions ? JSON.parse(r.extensions) : void 0,\n        error: r.error ? new n({\n          networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,\n          graphQLErrors: r.error.graphQLErrors\n        }) : void 0,\n        stale: !1,\n        hasNext: !!r.hasNext\n      }))(e, a[e.key], t);\n      if (r && !T.has(e.key)) {\n        i.stale = !0;\n        T.add(e.key);\n        reexecuteOperation(o, e);\n      }\n      return {\n        ...i,\n        operation: \"production\" !== process.env.NODE_ENV ? addMetadata(e, {\n          cacheOutcome: \"hit\"\n        }) : e\n      };\n    })(y(e => \"teardown\" !== e.kind && !!a[e.key] && \"network-only\" !== e.context.requestPolicy)(s));\n    if (!c) {\n      u = x(e => {\n        var {\n          operation: r\n        } = e;\n        if (\"mutation\" !== r.kind) {\n          var n = ((e, r) => {\n            var t = {\n              data: JSON.stringify(e.data),\n              hasNext: e.hasNext\n            };\n            if (void 0 !== e.data) {\n              t.data = JSON.stringify(e.data);\n            }\n            if (r && void 0 !== e.extensions) {\n              t.extensions = JSON.stringify(e.extensions);\n            }\n            if (e.error) {\n              t.error = {\n                graphQLErrors: e.error.graphQLErrors.map(e => {\n                  if (!e.path && !e.extensions) {\n                    return e.message;\n                  }\n                  return {\n                    message: e.message,\n                    path: e.path,\n                    extensions: e.extensions\n                  };\n                })\n              };\n              if (e.error.networkError) {\n                t.error.networkError = \"\" + e.error.networkError;\n              }\n            }\n            return t;\n          })(e, t);\n          a[r.key] = n;\n        }\n      })(u);\n    } else {\n      p = x(invalidate)(p);\n    }\n    return w([u, p]);\n  };\n  ssr.restoreData = e => {\n    for (var r in e) {\n      if (null !== a[r]) {\n        a[r] = e[r];\n      }\n    }\n  };\n  ssr.extractData = () => {\n    var e = {};\n    for (var r in a) {\n      if (null != a[r]) {\n        e[r] = a[r];\n      }\n    }\n    return e;\n  };\n  if (e && e.initialState) {\n    ssr.restoreData(e.initialState);\n  }\n  return ssr;\n};\nvar subscriptionExchange = ({\n  forwardSubscription: e,\n  enableAllOperations: r,\n  isSubscriptionOperation: t\n}) => ({\n  client: n,\n  forward: i\n}) => {\n  var u = t || (e => \"subscription\" === e.kind || !!r && (\"query\" === e.kind || \"mutation\" === e.kind));\n  return r => {\n    var t = g(t => {\n      var {\n        key: i\n      } = t;\n      var u = y(e => \"teardown\" === e.kind && e.key === i)(r);\n      return E(u)((r => {\n        var t = e(a(r), r);\n        return O(e => {\n          var a = !1;\n          var i;\n          var u;\n          function nextResult(t) {\n            e.next(u = u ? s(u, t) : c(r, t));\n          }\n          Promise.resolve().then(() => {\n            if (a) {\n              return;\n            }\n            i = t.subscribe({\n              next: nextResult,\n              error(t) {\n                if (Array.isArray(t)) {\n                  nextResult({\n                    errors: t\n                  });\n                } else {\n                  e.next(o(r, t));\n                }\n                e.complete();\n              },\n              complete() {\n                if (!a) {\n                  a = !0;\n                  if (\"subscription\" === r.kind) {\n                    n.reexecuteOperation(makeOperation(\"teardown\", r, r.context));\n                  }\n                  if (u && u.hasNext) {\n                    nextResult({\n                      hasNext: !1\n                    });\n                  }\n                  e.complete();\n                }\n              }\n            });\n          });\n          return () => {\n            a = !0;\n            if (i) {\n              i.unsubscribe();\n            }\n          };\n        });\n      })(t));\n    })(y(e => \"teardown\" !== e.kind && u(e))(r));\n    var p = i(y(e => \"teardown\" === e.kind || !u(e))(r));\n    return w([t, p]);\n  };\n};\nvar debugExchange = ({\n  forward: e\n}) => {\n  if (\"production\" === process.env.NODE_ENV) {\n    return r => e(r);\n  } else {\n    return r => x(e => console.log(\"[Exchange debug]: Completed operation: \", e))(e(x(e => console.log(\"[Exchange debug]: Incoming operation: \", e))(r)));\n  }\n};\nvar dedupExchange = ({\n  forward: e\n}) => r => e(r);\nvar fetchExchange = ({\n  forward: e,\n  dispatchDebug: r\n}) => t => {\n  var n = g(e => {\n    var n = a(e);\n    var o = u(e, n);\n    var i = p(e, n);\n    \"production\" !== process.env.NODE_ENV && r({\n      type: \"fetchRequest\",\n      message: \"A fetch request is being executed.\",\n      operation: e,\n      data: {\n        url: o,\n        fetchOptions: i\n      },\n      source: \"fetchExchange\"\n    });\n    var s = E(y(r => \"teardown\" === r.kind && r.key === e.key)(t))(d(e, o, i));\n    if (\"production\" !== process.env.NODE_ENV) {\n      return N(t => {\n        var n = !t.data ? t.error : void 0;\n        \"production\" !== process.env.NODE_ENV && r({\n          type: n ? \"fetchError\" : \"fetchSuccess\",\n          message: `A ${n ? \"failed\" : \"successful\"} fetch response has been returned.`,\n          operation: e,\n          data: {\n            url: o,\n            fetchOptions: i,\n            value: n || t\n          },\n          source: \"fetchExchange\"\n        });\n      })(s);\n    }\n    return s;\n  })(y(e => \"teardown\" !== e.kind && (\"subscription\" !== e.kind || !!e.context.fetchSubscriptions))(t));\n  var o = e(y(e => \"teardown\" === e.kind || \"subscription\" === e.kind && !e.context.fetchSubscriptions)(t));\n  return w([n, o]);\n};\nvar composeExchanges = e => ({\n  client: r,\n  forward: t,\n  dispatchDebug: n\n}) => e.reduceRight((e, t) => {\n  var a = !1;\n  return t({\n    client: r,\n    forward(r) {\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (a) {\n          throw new Error(\"forward() must only be called once in each Exchange.\");\n        }\n        a = !0;\n      }\n      return b(e(b(r)));\n    },\n    dispatchDebug(e) {\n      \"production\" !== process.env.NODE_ENV && n({\n        timestamp: Date.now(),\n        source: t.name,\n        ...e\n      });\n    }\n  });\n}, t);\nvar mapExchange = ({\n  onOperation: e,\n  onResult: r,\n  onError: t\n}) => ({\n  forward: n\n}) => a => g(e => {\n  if (t && e.error) {\n    t(e.error, e.operation);\n  }\n  var n = r && r(e) || e;\n  return \"then\" in n ? _(n) : q(n);\n})(n(g(r => {\n  var t = e && e(r) || r;\n  return \"then\" in t ? _(t) : q(t);\n})(a)));\nvar fallbackExchange = ({\n  dispatchDebug: e\n}) => r => {\n  if (\"production\" !== process.env.NODE_ENV) {\n    r = x(r => {\n      if (\"teardown\" !== r.kind && \"production\" !== process.env.NODE_ENV) {\n        var t = `No exchange has handled operations of kind \"${r.kind}\". Check whether you've added an exchange responsible for these operations.`;\n        \"production\" !== process.env.NODE_ENV && e({\n          type: \"fallbackCatch\",\n          message: t,\n          operation: r,\n          source: \"fallbackExchange\"\n        });\n        console.warn(t);\n      }\n    })(r);\n  }\n  return y(e => !1)(r);\n};\nvar C = function Client(e) {\n  if (\"production\" !== process.env.NODE_ENV && !e.url) {\n    throw new Error(\"You are creating an urql-client without a url.\");\n  }\n  var r = 0;\n  var t = new Map();\n  var n = new Map();\n  var a = new Set();\n  var o = [];\n  var i = {\n    url: e.url,\n    fetchSubscriptions: e.fetchSubscriptions,\n    fetchOptions: e.fetchOptions,\n    fetch: e.fetch,\n    preferGetMethod: e.preferGetMethod,\n    requestPolicy: e.requestPolicy || \"cache-first\"\n  };\n  var s = D();\n  function nextOperation(e) {\n    if (\"mutation\" === e.kind || \"teardown\" === e.kind || !a.has(e.key)) {\n      if (\"teardown\" === e.kind) {\n        a.delete(e.key);\n      } else if (\"mutation\" !== e.kind) {\n        a.add(e.key);\n      }\n      s.next(e);\n    }\n  }\n  var c = !1;\n  function dispatchOperation(e) {\n    if (e) {\n      nextOperation(e);\n    }\n    if (!c) {\n      c = !0;\n      while (c && (e = o.shift())) {\n        nextOperation(e);\n      }\n      c = !1;\n    }\n  }\n  var makeResultSource = r => {\n    var i = E(y(e => \"teardown\" === e.kind && e.key === r.key)(s.source))(y(e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance))(O));\n    if (e.maskTypename) {\n      i = m(e => ({\n        ...e,\n        data: maskTypename(e.data, !0)\n      }))(i);\n    }\n    if (\"query\" !== r.kind) {\n      i = A(e => !!e.hasNext, !0)(i);\n    } else {\n      i = V(e => {\n        var t = q(e);\n        return e.stale || e.hasNext ? t : w([t, m(() => {\n          e.stale = !0;\n          return e;\n        })(h(1)(y(e => e.key === r.key)(s.source)))]);\n      })(i);\n    }\n    if (\"mutation\" !== r.kind) {\n      i = M(() => {\n        a.delete(r.key);\n        t.delete(r.key);\n        n.delete(r.key);\n        c = !1;\n        for (var e = o.length - 1; e >= 0; e--) {\n          if (o[e].key === r.key) {\n            o.splice(e, 1);\n          }\n        }\n        nextOperation(makeOperation(\"teardown\", r, r.context));\n      })(N(e => {\n        if (e.stale) {\n          for (var n of o) {\n            if (n.key === e.operation.key) {\n              a.delete(n.key);\n              break;\n            }\n          }\n        } else if (!e.hasNext) {\n          a.delete(r.key);\n        }\n        t.set(r.key, e);\n      })(i));\n    } else {\n      i = P(() => {\n        nextOperation(r);\n      })(i);\n    }\n    return b(i);\n  };\n  var u = this instanceof Client ? this : Object.create(Client.prototype);\n  var p = Object.assign(u, {\n    suspense: !!e.suspense,\n    operations$: s.source,\n    reexecuteOperation(e) {\n      if (\"teardown\" === e.kind) {\n        dispatchOperation(e);\n      } else if (\"mutation\" === e.kind || n.has(e.key)) {\n        var r = !1;\n        for (var t = 0; t < o.length; t++) {\n          r = r || o[t].key === e.key;\n        }\n        if (!r) {\n          a.delete(e.key);\n        }\n        o.push(e);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n    createRequestOperation(e, t, n) {\n      if (!n) {\n        n = {};\n      }\n      var a;\n      if (\"production\" !== process.env.NODE_ENV && \"teardown\" !== e && (a = v(t.query)) !== e) {\n        throw new Error(`Expected operation of type \"${e}\" but found \"${a}\"`);\n      }\n      return makeOperation(e, t, {\n        _instance: \"mutation\" === e ? r = r + 1 | 0 : void 0,\n        ...i,\n        ...n,\n        requestPolicy: n.requestPolicy || i.requestPolicy,\n        suspense: n.suspense || !1 !== n.suspense && p.suspense\n      });\n    },\n    executeRequestOperation(e) {\n      if (\"mutation\" === e.kind) {\n        return withPromise(makeResultSource(e));\n      }\n      return withPromise(S(() => {\n        var r = n.get(e.key);\n        if (!r) {\n          n.set(e.key, r = makeResultSource(e));\n        }\n        r = P(() => {\n          dispatchOperation(e);\n        })(r);\n        var a = t.get(e.key);\n        if (\"query\" === e.kind && a && (a.stale || a.hasNext)) {\n          return V(q)(w([r, y(r => r === t.get(e.key))(q(a))]));\n        } else {\n          return r;\n        }\n      }));\n    },\n    executeQuery(e, r) {\n      var t = p.createRequestOperation(\"query\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeSubscription(e, r) {\n      var t = p.createRequestOperation(\"subscription\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeMutation(e, r) {\n      var t = p.createRequestOperation(\"mutation\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    readQuery(e, r, t) {\n      var n = null;\n      k(e => {\n        n = e;\n      })(p.query(e, r, t)).unsubscribe();\n      return n;\n    },\n    query: (e, r, t) => p.executeQuery(f(e, r), t),\n    subscription: (e, r, t) => p.executeSubscription(f(e, r), t),\n    mutation: (e, r, t) => p.executeMutation(f(e, r), t)\n  });\n  var d = noop;\n  if (\"production\" !== process.env.NODE_ENV) {\n    var {\n      next: l,\n      source: x\n    } = D();\n    p.subscribeToDebugTarget = e => k(e)(x);\n    d = l;\n  }\n  var g = composeExchanges(e.exchanges);\n  var O = b(g({\n    client: p,\n    dispatchDebug: d,\n    forward: fallbackExchange({\n      dispatchDebug: d\n    })\n  })(s.source));\n  R(O);\n  return p;\n};\nvar j = C;\nexport { C as Client, n as CombinedError, cacheExchange, composeExchanges, j as createClient, f as createRequest, debugExchange, dedupExchange, mapExchange as errorExchange, fetchExchange, formatDocument, gql, o as makeErrorResult, makeOperation, c as makeResult, mapExchange, maskTypename, s as mergeResultPatch, ssrExchange, t as stringifyDocument, subscriptionExchange };","map":{"version":3,"names":["collectTypes","e","r","Array","isArray","t","n","add","formatNode","definitions","a","push","directives","length","o","i","s","c","name","value","slice","_directives","u","p","kind","OPERATION_DEFINITION","selectionSet","d","selections","FIELD","alias","v","NAME","_generated","I","Map","formatDocument","get","__key","set","Object","defineProperty","enumerable","maskTypename","map","__typename","withPromise","source$","toPromise","l","h","y","stale","hasNext","then","subscribe","k","makeOperation","context","addMetadata","meta","noop","gql","arguments","unshift","FRAGMENT_DEFINITION","f","has","process","env","NODE_ENV","console","warn","DOCUMENT","shouldSkip","mapTypeNames","query","cacheExchange","forward","client","dispatchDebug","isOperationCached","requestPolicy","key","m","operation","type","message","source","cacheOutcome","reexecuteOperation","x","additionalTypenames","Set","data","concat","typenames","response","values","clear","delete","w","T","ssrExchange","staleWhileRevalidate","includeExtensions","invalidate","Promise","resolve","shift","ssr","isClient","suspense","JSON","parse","extensions","error","networkError","Error","graphQLErrors","stringify","path","restoreData","extractData","initialState","subscriptionExchange","forwardSubscription","enableAllOperations","isSubscriptionOperation","g","E","O","nextResult","next","errors","complete","unsubscribe","debugExchange","log","dedupExchange","fetchExchange","url","fetchOptions","N","fetchSubscriptions","composeExchanges","reduceRight","b","timestamp","Date","now","mapExchange","onOperation","onResult","onError","_","q","fallbackExchange","C","Client","fetch","preferGetMethod","D","nextOperation","dispatchOperation","makeResultSource","_instance","A","V","M","splice","P","create","prototype","assign","operations$","createRequestOperation","executeRequestOperation","S","executeQuery","executeSubscription","executeMutation","readQuery","subscription","mutation","subscribeToDebugTarget","exchanges","R","j"],"sources":["C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\collectTypenames.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\formatDocument.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\maskTypename.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\streamUtils.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\operation.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\utils\\index.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\gql.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\cache.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\ssr.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\subscription.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\debug.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\dedup.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\fetch.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\compose.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\map.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\exchanges\\fallback.ts","C:\\Users\\91630\\Desktop\\Voting-Dapp-master\\client\\node_modules\\@urql\\core\\src\\client.ts"],"sourcesContent":["interface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (obj: EntityLike | EntityLike[], types: Set<string>) => {\n  if (Array.isArray(obj)) {\n    for (const item of obj) collectTypes(item, types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types.add(obj[key] as string);\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\n/** Finds and returns a list of `__typename` fields found in response data.\n *\n * @privateRemarks\n * This is used by `@urql/core`’s document `cacheExchange` to find typenames\n * in a given GraphQL response’s data.\n */\nexport const collectTypenames = (response: object): string[] => [\n  ...collectTypes(response as EntityLike, new Set()),\n];\n","import type {\n  FieldNode,\n  SelectionNode,\n  DefinitionNode,\n  DirectiveNode,\n} from '@0no-co/graphql.web';\nimport { Kind } from '@0no-co/graphql.web';\nimport type { KeyedDocumentNode } from './request';\nimport { keyDocument } from './request';\nimport type { FormattedNode, TypedDocumentNode } from '../types';\n\nconst formatNode = <\n  T extends SelectionNode | DefinitionNode | TypedDocumentNode<any, any>,\n>(\n  node: T\n): FormattedNode<T> => {\n  if ('definitions' in node) {\n    const definitions: FormattedNode<DefinitionNode>[] = [];\n    for (const definition of node.definitions) {\n      const newDefinition = formatNode(definition);\n      definitions.push(newDefinition);\n    }\n\n    return { ...node, definitions } as FormattedNode<T>;\n  }\n\n  if ('directives' in node && node.directives && node.directives.length) {\n    const directives: DirectiveNode[] = [];\n    const _directives = {};\n    for (const directive of node.directives) {\n      let name = directive.name.value;\n      if (name[0] !== '_') {\n        directives.push(directive);\n      } else {\n        name = name.slice(1);\n      }\n      _directives[name] = directive;\n    }\n    node = { ...node, directives, _directives };\n  }\n\n  if ('selectionSet' in node) {\n    const selections: FormattedNode<SelectionNode>[] = [];\n    let hasTypename = node.kind === Kind.OPERATION_DEFINITION;\n    if (node.selectionSet) {\n      for (const selection of node.selectionSet.selections || []) {\n        hasTypename =\n          hasTypename ||\n          (selection.kind === Kind.FIELD &&\n            selection.name.value === '__typename' &&\n            !selection.alias);\n        const newSelection = formatNode(selection);\n        selections.push(newSelection);\n      }\n\n      if (!hasTypename) {\n        selections.push({\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename',\n          },\n          _generated: true,\n        } as FormattedNode<FieldNode>);\n      }\n\n      return {\n        ...node,\n        selectionSet: { ...node.selectionSet, selections },\n      } as FormattedNode<T>;\n    }\n  }\n\n  return node as FormattedNode<T>;\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\n/** Formats a GraphQL document to add `__typename` fields and process client-side directives.\n *\n * @param node - a {@link DocumentNode}.\n * @returns a {@link FormattedDocument}\n *\n * @remarks\n * Cache {@link Exchange | Exchanges} will require typename introspection to\n * recognize types in a GraphQL response. To retrieve these typenames,\n * this function is used to add the `__typename` fields to non-root\n * selection sets of a GraphQL document.\n *\n * Additionally, this utility will process directives, filter out client-side\n * directives starting with an `_` underscore, and place a `_directives` dictionary\n * on selection nodes.\n *\n * This utility also preserves the internally computed key of the\n * document as created by {@link createRequest} to avoid any\n * formatting from being duplicated.\n *\n * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n * on typename introspection via the `__typename` field.\n */\nexport const formatDocument = <T extends TypedDocumentNode<any, any>>(\n  node: T\n): FormattedNode<T> => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    formattedDocs.set(\n      query.__key,\n      (result = formatNode(query) as KeyedDocumentNode)\n    );\n    // Ensure that the hash of the resulting document won't suddenly change\n    // we are marking __key as non-enumerable so when external exchanges use visit\n    // to manipulate a document we won't restore the previous query due to the __key\n    // property.\n    Object.defineProperty(result, '__key', {\n      value: query.__key,\n      enumerable: false,\n    });\n  }\n\n  return result as FormattedNode<T>;\n};\n","/** Used to recursively mark `__typename` fields in data as non-enumerable.\n *\n * @deprecated Not recommended over modelling inputs manually (See #3299)\n *\n * @remarks\n * This utility can be used to recursively copy GraphQl response data and hide\n * all `__typename` fields present on it.\n *\n * Hint: It’s not recommended to do this, unless it's absolutely necessary as\n * cloning and modifying all data of a response can be unnecessarily slow, when\n * a manual and more specific copy/mask is more efficient.\n *\n * @see {@link ClientOptions.maskTypename} for a description of how the `Client` uses this utility.\n */\nexport const maskTypename = (data: any, isRoot?: boolean): any => {\n  if (!data || typeof data !== 'object') {\n    return data;\n  } else if (Array.isArray(data)) {\n    return data.map(d => maskTypename(d));\n  } else if (\n    data &&\n    typeof data === 'object' &&\n    (isRoot || '__typename' in data)\n  ) {\n    const acc = {};\n    for (const key in data) {\n      if (key === '__typename') {\n        Object.defineProperty(acc, '__typename', {\n          enumerable: false,\n          value: data.__typename,\n        });\n      } else {\n        acc[key] = maskTypename(data[key]);\n      }\n    }\n    return acc;\n  } else {\n    return data;\n  }\n};\n","import type { Sink, Source } from 'wonka';\nimport { subscribe, take, filter, toPromise, pipe } from 'wonka';\nimport type { OperationResult, OperationResultSource } from '../types';\n\n/** Patches a `toPromise` method onto the `Source` passed to it.\n * @param source$ - the Wonka {@link Source} to patch.\n * @returns The passed `source$` with a patched `toPromise` method as a {@link PromisifiedSource}.\n * @internal\n */\nexport function withPromise<T extends OperationResult>(\n  _source$: Source<T>\n): OperationResultSource<T> {\n  const source$ = ((sink: Sink<T>) =>\n    _source$(sink)) as OperationResultSource<T>;\n  source$.toPromise = () =>\n    pipe(\n      source$,\n      filter(result => !result.stale && !result.hasNext),\n      take(1),\n      toPromise\n    );\n  source$.then = (onResolve, onReject) =>\n    source$.toPromise().then(onResolve, onReject);\n  source$.subscribe = onResult => subscribe(onResult)(source$);\n  return source$;\n}\n","import type {\n  AnyVariables,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\n\n/** Creates a {@link Operation} from the given parameters.\n *\n * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n * @param request - The {@link GraphQLRequest} or {@link Operation} used as a template for the new `Operation`.\n * @param context - The {@link OperationContext} `context` data for the `Operation`.\n * @returns A new {@link Operation}.\n *\n * @remarks\n * This method is both used to create new {@link Operation | Operations} as well as copy and modify existing\n * operations. While it’s not required to use this function to copy an `Operation`, it is recommended, in case\n * additional dynamic logic is added to them in the future.\n *\n * Hint: When an {@link Operation} is passed to the `request` argument, the `context` argument does not have to be\n * a complete {@link OperationContext} and will instead be combined with passed {@link Operation.context}.\n *\n * @example\n * An example of copying an existing `Operation` to modify its `context`:\n *\n * ```ts\n * makeOperation(\n *   operation.kind,\n *   operation,\n *   { requestPolicy: 'cache-first' },\n * );\n * ```\n */\nfunction makeOperation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: Partial<OperationContext>\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  return {\n    ...request,\n    kind,\n    context: request.context\n      ? {\n          ...request.context,\n          ...context,\n        }\n      : context || request.context,\n  };\n}\n\nexport { makeOperation };\n\n/** Adds additional metadata to an `Operation`'s `context.meta` property while copying it.\n * @see {@link OperationDebugMeta} for more information on the {@link OperationContext.meta} property.\n */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n","export * from './error';\nexport * from './request';\nexport * from './result';\nexport * from './variables';\nexport * from './collectTypenames';\nexport * from './formatDocument';\nexport * from './maskTypename';\nexport * from './streamUtils';\nexport * from './operation';\n\nexport const noop = () => {\n  /* noop */\n};\n","/* eslint-disable prefer-rest-params */\nimport { Kind } from '@0no-co/graphql.web';\nimport type { DocumentNode, DefinitionNode } from './utils/graphql';\nimport type { AnyVariables, TypedDocumentNode } from './types';\nimport { keyDocument, stringifyDocument } from './utils';\n\n/** A GraphQL parse function, which may be called as a tagged template literal, returning a parsed {@link DocumentNode}.\n *\n * @remarks\n * The `gql` tag or function is used to parse a GraphQL query document into a {@link DocumentNode}.\n *\n * When used as a tagged template, `gql` will automatically merge fragment definitions into the resulting\n * document and deduplicate them.\n *\n * It enforces that all fragments have a unique name. When fragments with different definitions share a name,\n * it will log a warning in development.\n *\n * Hint: It’s recommended to use this `gql` function over other GraphQL parse functions, since it puts the parsed\n * results directly into `@urql/core`’s internal caches and prevents further unnecessary work.\n *\n * @example\n * ```ts\n * const AuthorFragment = gql`\n *   fragment AuthorDisplayComponent on Author {\n *     id\n *     name\n *   }\n * `;\n *\n * const BookFragment = gql`\n *   fragment ListBookComponent on Book {\n *     id\n *     title\n *     author {\n *       ...AuthorDisplayComponent\n *     }\n *   }\n *\n *   ${AuthorFragment}\n * `;\n *\n * const BookQuery = gql`\n *   query Book($id: ID!) {\n *     book(id: $id) {\n *       ...BookFragment\n *     }\n *   }\n *\n *   ${BookFragment}\n * `;\n * ```\n */\nfunction gql<Data = any, Variables extends AnyVariables = AnyVariables>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables extends AnyVariables = AnyVariables>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(parts: string | TemplateStringsArray /* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const source: DocumentNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(parts) ? parts[0] : parts || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      source.push(value);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  source.unshift(keyDocument(body));\n  for (const document of source) {\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        const name = definition.name.value;\n        const value = stringifyDocument(definition);\n        // Fragments will be deduplicated according to this Map\n        if (!fragmentNames.has(name)) {\n          fragmentNames.set(name, value);\n          definitions.push(definition);\n        } else if (\n          process.env.NODE_ENV !== 'production' &&\n          fragmentNames.get(name) !== value\n        ) {\n          // Fragments with the same names is expected to have the same contents\n          console.warn(\n            '[WARNING: Duplicate Fragment] A fragment with name `' +\n              name +\n              '` already exists in this document.\\n' +\n              'While fragment names may not be unique across your source, each name must be unique per document.'\n          );\n        }\n      } else {\n        definitions.push(definition);\n      }\n    }\n  }\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, tap } from 'wonka';\n\nimport type { Client } from '../client';\nimport type { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypenames,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\ntype OperationCache = Map<string, Set<number>>;\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\n/** Adds unique typenames to query (for invalidating cache entries) */\nexport const mapTypeNames = (operation: Operation): Operation => {\n  const query = formatDocument(operation.query);\n  if (query !== operation.query) {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = query;\n    return formattedOperation;\n  } else {\n    return operation;\n  }\n};\n\n/** Default document cache exchange.\n *\n * @remarks\n * The default document cache in `urql` avoids sending the same GraphQL request\n * multiple times by caching it using the {@link Operation.key}. It will invalidate\n * query results automatically whenever it sees a mutation responses with matching\n * `__typename`s in their responses.\n *\n * The document cache will get the introspected `__typename` fields by modifying\n * your GraphQL operation documents using the {@link formatDocument} utility.\n *\n * This automatic invalidation strategy can fail if your query or mutation don’t\n * contain matching typenames, for instance, because the query contained an\n * empty list.\n * You can manually add hints for this exchange by specifying a list of\n * {@link OperationContext.additionalTypenames} for queries and mutations that\n * should invalidate one another.\n *\n * @see {@link https://urql.dev/goto/docs/basics/document-caching} for more information on this cache.\n */\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache: ResultCache = new Map();\n  const operationCache: OperationCache = new Map();\n\n  const isOperationCached = (operation: Operation) =>\n    operation.kind === 'query' &&\n    operation.context.requestPolicy !== 'network-only' &&\n    (operation.context.requestPolicy === 'cache-only' ||\n      resultCache.has(operation.key));\n\n  return ops$ => {\n    const cachedOps$ = pipe(\n      ops$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        let result: OperationResult = cachedResult!;\n        if (process.env.NODE_ENV !== 'production') {\n          result = {\n            ...result,\n            operation: addMetadata(operation, {\n              cacheOutcome: cachedResult ? 'hit' : 'miss',\n            }),\n          };\n        }\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          ops$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          ops$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        let typenames = operation.context.additionalTypenames || [];\n        // NOTE: For now, we only respect `additionalTypenames` from subscriptions to\n        // avoid unexpected breaking changes\n        // We'd expect live queries or other update mechanisms to be more suitable rather\n        // than using subscriptions as “signals” to reexecute queries. However, if they’re\n        // just used as signals, it’s intuitive to hook them up using `additionalTypenames`\n        if (response.operation.kind !== 'subscription') {\n          typenames = collectTypenames(response.data).concat(typenames);\n        }\n\n        // Invalidates the cache given a mutation's response\n        if (\n          response.operation.kind === 'mutation' ||\n          response.operation.kind === 'subscription'\n        ) {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            let operations = operationCache.get(typeName);\n            if (!operations)\n              operationCache.set(typeName, (operations = new Set()));\n            for (const key of operations.values()) pendingOperations.add(key);\n            operations.clear();\n          }\n\n          for (const key of pendingOperations.values()) {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          }\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            let operations = operationCache.get(typeName);\n            if (!operations)\n              operationCache.set(typeName, (operations = new Set()));\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n/** Reexecutes an `Operation` with the `network-only` request policy.\n * @internal\n */\nexport const reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      requestPolicy: 'network-only',\n    })\n  );\n};\n","import type { GraphQLError } from '../utils/graphql';\nimport { pipe, filter, merge, map, tap } from 'wonka';\nimport type { Exchange, OperationResult, Operation } from '../types';\nimport { addMetadata, CombinedError } from '../utils';\nimport { reexecuteOperation, mapTypeNames } from './cache';\n\n/** A serialized version of an {@link OperationResult}.\n *\n * @remarks\n * All properties are serialized separately as JSON strings, except for the\n * {@link CombinedError} to speed up JS parsing speed, even if a result doesn’t\n * end up being used.\n *\n * @internal\n */\nexport interface SerializedResult {\n  hasNext?: boolean;\n  /** JSON-serialized version of {@link OperationResult.data}. */\n  data?: string | undefined; // JSON string of data\n  /** JSON-serialized version of {@link OperationResult.extensions}. */\n  extensions?: string | undefined;\n  /** JSON version of {@link CombinedError}. */\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\n/** A dictionary of {@link Operation.key} keys to serializable {@link SerializedResult} objects.\n *\n * @remarks\n * It’s not recommended to modify the serialized data manually, however, multiple payloads of\n * this dictionary may safely be merged and combined.\n */\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\n/** Options for the `ssrExchange` allowing it to either operate on the server- or client-side. */\nexport interface SSRExchangeParams {\n  /** Indicates to the {@link SSRExchange} whether it's currently in server-side or client-side mode.\n   *\n   * @remarks\n   * Depending on this option, the {@link SSRExchange} will either capture or replay results.\n   * When `true`, it’s in client-side mode and results will be serialized. When `false`, it’ll\n   * use its deserialized data and replay results from it.\n   */\n  isClient?: boolean;\n  /** May be used on the client-side to pass the {@link SSRExchange} serialized data from the server-side.\n   *\n   * @remarks\n   * Alternatively, {@link SSRExchange.restoreData} may be called to imperatively add serialized data to\n   * the exchange.\n   *\n   * Hint: This method also works on the server-side to add to the initial serialized data, which enables\n   * you to combine multiple {@link SSRExchange} results, as needed.\n   */\n  initialState?: SSRData;\n  /** Forces a new API request to be sent in the background after replaying the deserialized result.\n   *\n   * @remarks\n   * Similarly to the `cache-and-network` {@link RequestPolicy}, this option tells the {@link SSRExchange}\n   * to send a new API request for the {@link Operation} after replaying a serialized result.\n   *\n   * Hint: This is useful when you're caching SSR results and need the client-side to update itself after\n   * rendering the initial serialized SSR results.\n   */\n  staleWhileRevalidate?: boolean;\n  /** Forces {@link OperationResult.extensions} to be serialized alongside the rest of a result.\n   *\n   * @remarks\n   * Entries in the `extension` object of a GraphQL result are often non-standard metdata, and many\n   * APIs use it for data that changes between every request. As such, the {@link SSRExchange} will\n   * not serialize this data by default, unless this flag is set.\n   */\n  includeExtensions?: boolean;\n}\n\n/** An `SSRExchange` either in server-side mode, serializing results, or client-side mode, deserializing and replaying results..\n *\n * @remarks\n * This same {@link Exchange} is used in your code both for the client-side and server-side as it’s “universal”\n * and can be put into either client-side or server-side mode using the {@link SSRExchangeParams.isClient} flag.\n *\n * In server-side mode, the `ssrExchange` will “record” results it sees from your API and provide them for you\n * to send to the client-side using the {@link SSRExchange.extractData} method.\n *\n * In client-side mode, the `ssrExchange` will use these serialized results, rehydrated either using\n * {@link SSRExchange.restoreData} or {@link SSRexchangeParams.initialState}, to replay results the\n * server-side has seen and sent before.\n *\n * Each serialized result will only be replayed once, as it’s assumed that your cache exchange will have the\n * results cached afterwards.\n */\nexport interface SSRExchange extends Exchange {\n  /** Client-side method to add serialized results to the {@link SSRExchange}.\n   * @param data - {@link SSRData},\n   */\n  restoreData(data: SSRData): void;\n  /** Server-side method to get all serialized results the {@link SSRExchange} has captured.\n   * @returns an {@link SSRData} dictionary.\n   */\n  extractData(): SSRData;\n}\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = (\n  result: OperationResult,\n  includeExtensions: boolean\n): SerializedResult => {\n  const serialized: SerializedResult = {\n    data: JSON.stringify(result.data),\n    hasNext: result.hasNext,\n  };\n\n  if (result.data !== undefined) {\n    serialized.data = JSON.stringify(result.data);\n  }\n\n  if (includeExtensions && result.extensions !== undefined) {\n    serialized.extensions = JSON.stringify(result.extensions);\n  }\n\n  if (result.error) {\n    serialized.error = {\n      graphQLErrors: result.error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (result.error.networkError) {\n      serialized.error.networkError = '' + result.error.networkError;\n    }\n  }\n\n  return serialized;\n};\n\n/** Deserialize plain JSON to an OperationResult\n * @internal\n */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult,\n  includeExtensions: boolean\n): OperationResult => ({\n  operation,\n  data: result.data ? JSON.parse(result.data) : undefined,\n  extensions:\n    includeExtensions && result.extensions\n      ? JSON.parse(result.extensions)\n      : undefined,\n  error: result.error\n    ? new CombinedError({\n        networkError: result.error.networkError\n          ? new Error(result.error.networkError)\n          : undefined,\n        graphQLErrors: result.error.graphQLErrors,\n      })\n    : undefined,\n  stale: false,\n  hasNext: !!result.hasNext,\n});\n\nconst revalidated = new Set<number>();\n\n/** Creates a server-side rendering `Exchange` that either captures responses on the server-side or replays them on the client-side.\n *\n * @param params - An {@link SSRExchangeParams} configuration object.\n * @returns the created {@link SSRExchange}\n *\n * @remarks\n * When dealing with server-side rendering, we essentially have two {@link Client | Clients} making requests,\n * the server-side client, and the client-side one. The `ssrExchange` helps implementing a tiny cache on both\n * sides that:\n *\n * - captures results on the server-side which it can serialize,\n * - replays results on the client-side that it deserialized from the server-side.\n *\n * Hint: The `ssrExchange` is basically an exchange that acts like a replacement for any fetch exchange\n * temporarily. As such, you should place it after your cache exchange but in front of any fetch exchange.\n */\nexport const ssrExchange = (params: SSRExchangeParams = {}): SSRExchange => {\n  const staleWhileRevalidate = !!params.staleWhileRevalidate;\n  const includeExtensions = !!params.includeExtensions;\n  const data: Record<string, SerializedResult | null> = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) {\n          data[key] = null;\n        }\n      });\n    }\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange =\n    ({ client, forward }) =>\n    ops$ => {\n      // params.isClient tells us whether we're on the client-side\n      // By default we assume that we're on the client if suspense-mode is disabled\n      const isClient =\n        params && typeof params.isClient === 'boolean'\n          ? !!params.isClient\n          : !client.suspense;\n\n      let forwardedOps$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind === 'teardown' ||\n            !data[operation.key] ||\n            !!data[operation.key]!.hasNext ||\n            operation.context.requestPolicy === 'network-only'\n        ),\n        map(mapTypeNames),\n        forward\n      );\n\n      // NOTE: Since below we might delete the cached entry after accessing\n      // it once, cachedOps$ needs to be merged after forwardedOps$\n      let cachedOps$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind !== 'teardown' &&\n            !!data[operation.key] &&\n            operation.context.requestPolicy !== 'network-only'\n        ),\n        map(op => {\n          const serialized = data[op.key]!;\n          const cachedResult = deserializeResult(\n            op,\n            serialized,\n            includeExtensions\n          );\n\n          if (staleWhileRevalidate && !revalidated.has(op.key)) {\n            cachedResult.stale = true;\n            revalidated.add(op.key);\n            reexecuteOperation(client, op);\n          }\n\n          const result: OperationResult = {\n            ...cachedResult,\n            operation: addMetadata(op, {\n              cacheOutcome: 'hit',\n            }),\n          };\n          return result;\n        })\n      );\n\n      if (!isClient) {\n        // On the server we cache results in the cache as they're resolved\n        forwardedOps$ = pipe(\n          forwardedOps$,\n          tap((result: OperationResult) => {\n            const { operation } = result;\n            if (operation.kind !== 'mutation') {\n              const serialized = serializeResult(result, includeExtensions);\n              data[operation.key] = serialized;\n            }\n          })\n        );\n      } else {\n        // On the client we delete results from the cache as they're resolved\n        cachedOps$ = pipe(cachedOps$, tap(invalidate));\n      }\n\n      return merge([forwardedOps$, cachedOps$]);\n    };\n\n  ssr.restoreData = (restore: SSRData) => {\n    for (const key in restore) {\n      // We only restore data that hasn't been previously invalidated\n      if (data[key] !== null) {\n        data[key] = restore[key];\n      }\n    }\n  };\n\n  ssr.extractData = () => {\n    const result: SSRData = {};\n    for (const key in data) if (data[key] != null) result[key] = data[key]!;\n    return result;\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","import type { Subscription, Source } from 'wonka';\nimport { filter, make, merge, mergeMap, pipe, takeUntil } from 'wonka';\n\nimport {\n  makeResult,\n  mergeResultPatch,\n  makeErrorResult,\n  makeOperation,\n} from '../utils';\n\nimport type {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationResult,\n} from '../types';\n\nimport type { FetchBody } from '../internal';\nimport { makeFetchBody } from '../internal';\n\n/** An abstract observer-like interface.\n *\n * @remarks\n * Observer-like interfaces are passed to {@link ObservableLike.subscribe} to provide them\n * with callbacks for their events.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\nexport interface ObserverLike<T> {\n  /** Callback for values an {@link ObservableLike} emits. */\n  next: (value: T) => void;\n  /** Callback for an error an {@link ObservableLike} emits, which ends the subscription. */\n  error: (err: any) => void;\n  /** Callback for the completion of an {@link ObservableLike}, which ends the subscription. */\n  complete: () => void;\n}\n\n/** An abstract observable-like interface.\n *\n * @remarks\n * Observable, or Observable-like interfaces, are often used by GraphQL transports to abstract\n * how they send {@link ExecutionResult | ExecutionResults} to consumers. These generally contain\n * a `subscribe` method accepting an {@link ObserverLike} structure.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\nexport interface ObservableLike<T> {\n  /** Start the Observable-like subscription and returns a subscription handle.\n   *\n   * @param observer - an {@link ObserverLike} object with result, error, and completion callbacks.\n   * @returns a subscription handle providing an `unsubscribe` method to stop the subscription.\n   */\n  subscribe(observer: ObserverLike<T>): {\n    unsubscribe: () => void;\n  };\n}\n\n/** A more cross-compatible version of the {@link GraphQLRequest} structure.\n * {@link FetchBody} for more details\n */\nexport type SubscriptionOperation = FetchBody;\n\n/** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n *\n * @param operation - A {@link SubscriptionOperation}\n * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n */\nexport type SubscriptionForwarder = (\n  request: FetchBody,\n  operation: Operation\n) => ObservableLike<ExecutionResult>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  /** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n   *\n   * @param operation - A {@link SubscriptionOperation}\n   * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n   *\n   * @remarks\n   * This callback is called for each {@link Operation} that this `subscriptionExchange` will\n   * handle. It receives the {@link SubscriptionOperation}, which is a more compatible version\n   * of the raw {@link Operation} objects and must return an {@link ObservableLike} of results.\n   */\n  forwardSubscription: SubscriptionForwarder;\n\n  /** Flag to enable this exchange to handle all types of GraphQL operations.\n   *\n   * @remarks\n   * When you aren’t using fetch exchanges and GraphQL over HTTP as a transport for your GraphQL requests,\n   * or you have a third-party GraphQL transport implementation, which must also be used for queries and\n   * mutations, this flag may be used to allow this exchange to handle all kinds of GraphQL operations.\n   *\n   * By default, this flag is `false` and the exchange will only handle GraphQL subscription operations.\n   */\n  enableAllOperations?: boolean;\n\n  /** A predicate function that causes an operation to be handled by this `subscriptionExchange` if `true` is returned.\n   *\n   * @param operation - an {@link Operation}\n   * @returns true when the operation is handled by this exchange.\n   *\n   * @remarks\n   * In some cases, a `subscriptionExchange` will be used to only handle some {@link Operation | Operations},\n   * e.g. all that contain `@live` directive. For these cases, this function may be passed to precisely\n   * determine which `Operation`s this exchange should handle, instead of forwarding.\n   *\n   * When specified, the {@link SubscriptionExchangeOpts.enableAllOperations} flag is disregarded.\n   */\n  isSubscriptionOperation?: (operation: Operation) => boolean;\n}\n\n/** Generic subscription exchange factory used to either create an exchange handling just subscriptions or all operation kinds.\n *\n * @remarks\n * `subscriptionExchange` can be used to create an {@link Exchange} that either\n * handles just GraphQL subscription operations, or optionally all operations,\n * when the {@link SubscriptionExchangeOpts.enableAllOperations} flag is passed.\n *\n * The {@link SubscriptionExchangeOpts.forwardSubscription} function must\n * be provided and provides a generic input that's based on {@link Operation}\n * but is compatible with many libraries implementing GraphQL request or\n * subscription interfaces.\n */\nexport const subscriptionExchange =\n  ({\n    forwardSubscription,\n    enableAllOperations,\n    isSubscriptionOperation,\n  }: SubscriptionExchangeOpts): Exchange =>\n  ({ client, forward }) => {\n    const createSubscriptionSource = (\n      operation: Operation\n    ): Source<OperationResult> => {\n      const observableish = forwardSubscription(\n        makeFetchBody(operation),\n        operation\n      );\n\n      return make<OperationResult>(observer => {\n        let isComplete = false;\n        let sub: Subscription | void;\n        let result: OperationResult | void;\n\n        function nextResult(value: ExecutionResult) {\n          observer.next(\n            (result = result\n              ? mergeResultPatch(result, value)\n              : makeResult(operation, value))\n          );\n        }\n\n        Promise.resolve().then(() => {\n          if (isComplete) return;\n\n          sub = observableish.subscribe({\n            next: nextResult,\n            error(error) {\n              if (Array.isArray(error)) {\n                // NOTE: This is an exception for transports that deliver `GraphQLError[]`, as part\n                // of the observer’s error callback (may happen as part of `graphql-ws`).\n                // We only check for arrays here, as this is an extremely “unexpected” case as the\n                // shape of `ExecutionResult` is instead strictly defined.\n                nextResult({ errors: error });\n              } else {\n                observer.next(makeErrorResult(operation, error));\n              }\n              observer.complete();\n            },\n            complete() {\n              if (!isComplete) {\n                isComplete = true;\n                if (operation.kind === 'subscription') {\n                  client.reexecuteOperation(\n                    makeOperation('teardown', operation, operation.context)\n                  );\n                }\n                if (result && result.hasNext) {\n                  nextResult({ hasNext: false });\n                }\n                observer.complete();\n              }\n            },\n          });\n        });\n\n        return () => {\n          isComplete = true;\n          if (sub) sub.unsubscribe();\n        };\n      });\n    };\n\n    const isSubscriptionOperationFn =\n      isSubscriptionOperation ||\n      (operation =>\n        operation.kind === 'subscription' ||\n        (!!enableAllOperations &&\n          (operation.kind === 'query' || operation.kind === 'mutation')));\n\n    return ops$ => {\n      const subscriptionResults$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind !== 'teardown' &&\n            isSubscriptionOperationFn(operation)\n        ),\n        mergeMap(operation => {\n          const { key } = operation;\n          const teardown$ = pipe(\n            ops$,\n            filter(op => op.kind === 'teardown' && op.key === key)\n          );\n\n          return pipe(\n            createSubscriptionSource(operation),\n            takeUntil(teardown$)\n          );\n        })\n      );\n\n      const forward$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind === 'teardown' ||\n            !isSubscriptionOperationFn(operation)\n        ),\n        forward\n      );\n\n      return merge([subscriptionResults$, forward$]);\n    };\n  };\n","import { pipe, tap } from 'wonka';\nimport type { Exchange } from '../types';\n\n/** Simple log debugger exchange.\n *\n * @remarks\n * An exchange that logs incoming {@link Operation | Operations} and\n * {@link OperationResult | OperationResults} in development.\n *\n * This exchange is a no-op in production and often used in issue reporting\n * to understand certain usage patterns of `urql` without having access to\n * the original source code.\n *\n * Hint: When you report an issue you’re having with `urql`, adding\n * this as your first exchange and posting its output can speed up\n * issue triaging a lot!\n */\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import type { Exchange } from '../types';\n\n/** Default deduplication exchange.\n * @deprecated\n * This exchange's functionality is now built into the {@link Client}.\n */\nexport const dedupExchange: Exchange =\n  ({ forward }) =>\n  ops$ =>\n    forward(ops$);\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, takeUntil, onPush } from 'wonka';\n\nimport type { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** Default GraphQL over HTTP fetch exchange.\n *\n * @remarks\n * The default fetch exchange in `urql` supports sending GraphQL over HTTP\n * requests, can optionally send GraphQL queries as GET requests, and\n * handles incremental multipart responses.\n *\n * This exchange does not handle persisted queries or multipart uploads.\n * Support for the former can be added using `@urql/exchange-persisted-fetch`\n * and the latter using `@urql/exchange-multipart-fetch`.\n *\n * Hint: The `fetchExchange` and the two other exchanges all use the built-in fetch\n * utilities in `@urql/core/internal`, which you can also use to implement\n * a customized fetch exchange.\n *\n * @see {@link makeFetchSource} for the shared utility calling the Fetch API.\n */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const fetchResults$ = pipe(\n      ops$,\n      filter(operation => {\n        return (\n          operation.kind !== 'teardown' &&\n          (operation.kind !== 'subscription' ||\n            !!operation.context.fetchSubscriptions)\n        );\n      }),\n      mergeMap(operation => {\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        const source = pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(\n            pipe(\n              ops$,\n              filter(op => op.kind === 'teardown' && op.key === operation.key)\n            )\n          )\n        );\n\n        if (process.env.NODE_ENV !== 'production') {\n          return pipe(\n            source,\n            onPush(result => {\n              const error = !result.data ? result.error : undefined;\n\n              dispatchDebug({\n                type: error ? 'fetchError' : 'fetchSuccess',\n                message: `A ${\n                  error ? 'failed' : 'successful'\n                } fetch response has been returned.`,\n                operation,\n                data: {\n                  url,\n                  fetchOptions,\n                  value: error || result,\n                },\n              });\n            })\n          );\n        }\n\n        return source;\n      })\n    );\n\n    const forward$ = pipe(\n      ops$,\n      filter(operation => {\n        return (\n          operation.kind === 'teardown' ||\n          (operation.kind === 'subscription' &&\n            !operation.context.fetchSubscriptions)\n        );\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n","import { share } from 'wonka';\nimport type { ExchangeIO, Exchange, ExchangeInput } from '../types';\n\n/** Composes an array of Exchanges into a single one.\n *\n * @param exchanges - An array of {@link Exchange | Exchanges}.\n * @returns - A composed {@link Exchange}.\n *\n * @remarks\n * `composeExchanges` returns an {@link Exchange} that when instantiated\n * composes the array of passed `Exchange`s into one, calling them from\n * right to left, with the prior `Exchange`’s {@link ExchangeIO} function\n * as the {@link ExchangeInput.forward} input.\n *\n * This simply merges all exchanges into one and is used by the {@link Client}\n * to merge the `exchanges` option it receives.\n *\n * @throws\n * In development, if {@link ExchangeInput.forward} is called repeatedly\n * by an {@link Exchange} an error is thrown, since `forward()` must only\n * be called once per `Exchange`.\n */\nexport const composeExchanges =\n  (exchanges: Exchange[]): Exchange =>\n  ({ client, forward, dispatchDebug }: ExchangeInput): ExchangeIO =>\n    exchanges.reduceRight((forward, exchange) => {\n      let forwarded = false;\n      return exchange({\n        client,\n        forward(operations$) {\n          if (process.env.NODE_ENV !== 'production') {\n            if (forwarded)\n              throw new Error(\n                'forward() must only be called once in each Exchange.'\n              );\n            forwarded = true;\n          }\n          return share(forward(share(operations$)));\n        },\n        dispatchDebug(event) {\n          dispatchDebug({\n            timestamp: Date.now(),\n            source: exchange.name,\n            ...event,\n          });\n        },\n      });\n    }, forward);\n","import { mergeMap, fromValue, fromPromise, pipe } from 'wonka';\nimport type { Operation, OperationResult, Exchange } from '../types';\nimport type { CombinedError } from '../utils';\n\n/** Options for the `mapExchange` allowing it to react to incoming operations, results, or errors. */\nexport interface MapExchangeOpts {\n  /** Accepts a callback for incoming `Operation`s.\n   *\n   * @param operation - An {@link Operation} that the {@link mapExchange} received.\n   * @returns optionally a new {@link Operation} replacing the original.\n   *\n   * @remarks\n   * You may return new {@link Operation | Operations} from this function replacing\n   * the original that the {@link mapExchange} received.\n   * It’s recommended that you use the {@link makeOperation} utility to create a copy\n   * of the original when you do this. (However, this isn’t required)\n   *\n   * Hint: The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onOperation?(operation: Operation): Promise<Operation> | Operation | void;\n  /** Accepts a callback for incoming `OperationResult`s.\n   *\n   * @param result - An {@link OperationResult} that the {@link mapExchange} received.\n   * @returns optionally a new {@link OperationResult} replacing the original.\n   *\n   * @remarks\n   * This callback may optionally return a new {@link OperationResult} that replaces the original,\n   * which you can use to modify incoming API results.\n   *\n   * Hint: The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onResult?(\n    result: OperationResult\n  ): Promise<OperationResult> | OperationResult | void;\n  /** Accepts a callback for incoming `CombinedError`s.\n   *\n   * @param error - A {@link CombinedError} that an incoming {@link OperationResult} contained.\n   * @param operation - The {@link Operation} of the incoming {@link OperationResult}.\n   *\n   * @remarks\n   * The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onError?(error: CombinedError, operation: Operation): void;\n}\n\n/** Creates an `Exchange` mapping over incoming operations, results, and/or errors.\n *\n * @param opts - A {@link MapExchangeOpts} configuration object, containing the callbacks the `mapExchange` will use.\n * @returns the created {@link Exchange}\n *\n * @remarks\n * The `mapExchange` may be used to react to or modify incoming {@link Operation | Operations}\n * and {@link OperationResult | OperationResults}. Optionally, it can also modify these\n * asynchronously, when a promise is returned from the callbacks.\n *\n * This is useful to, for instance, add an authentication token to a given request, when\n * the `@urql/exchange-auth` package would be overkill.\n *\n * It can also accept an `onError` callback, which can be used to react to incoming\n * {@link CombinedError | CombinedErrors} on results, and trigger side-effects.\n *\n */\nexport const mapExchange = ({\n  onOperation,\n  onResult,\n  onError,\n}: MapExchangeOpts): Exchange => {\n  return ({ forward }) =>\n    ops$ => {\n      return pipe(\n        pipe(\n          ops$,\n          mergeMap(operation => {\n            const newOperation =\n              (onOperation && onOperation(operation)) || operation;\n            return 'then' in newOperation\n              ? fromPromise(newOperation)\n              : fromValue(newOperation);\n          })\n        ),\n        forward,\n        mergeMap(result => {\n          if (onError && result.error) onError(result.error, result.operation);\n          const newResult = (onResult && onResult(result)) || result;\n          return 'then' in newResult\n            ? fromPromise(newResult)\n            : fromValue(newResult);\n        })\n      );\n    };\n};\n","import { filter, pipe, tap } from 'wonka';\nimport type { ExchangeIO, ExchangeInput } from '../types';\n\n/** Used by the `Client` as the last exchange to warn about unhandled operations.\n *\n * @remarks\n * In a normal setup, some operations may go unhandled when a {@link Client} isn’t set up\n * with the right exchanges.\n * For instance, a `Client` may be missing a fetch exchange, or an exchange handling subscriptions.\n * This {@link Exchange} is added by the `Client` automatically to log warnings about unhandled\n * {@link Operaiton | Operations} in development.\n */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO =\n  ({ dispatchDebug }) =>\n  ops$ => {\n    if (process.env.NODE_ENV !== 'production') {\n      ops$ = pipe(\n        ops$,\n        tap(operation => {\n          if (\n            operation.kind !== 'teardown' &&\n            process.env.NODE_ENV !== 'production'\n          ) {\n            const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n            dispatchDebug({\n              type: 'fallbackCatch',\n              message,\n              operation,\n            });\n            console.warn(message);\n          }\n        })\n      );\n    }\n\n    // All operations that skipped through the entire exchange chain should be filtered from the output\n    return filter((_x): _x is never => false)(ops$);\n  };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport type { Source, Subscription } from 'wonka';\nimport {\n  lazy,\n  filter,\n  makeSubject,\n  onEnd,\n  onPush,\n  onStart,\n  pipe,\n  share,\n  take,\n  takeUntil,\n  takeWhile,\n  publish,\n  subscribe,\n  switchMap,\n  fromValue,\n  merge,\n  map,\n} from 'wonka';\n\nimport { composeExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport type {\n  DocumentInput,\n  AnyVariables,\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationInstance,\n  OperationContext,\n  OperationResult,\n  OperationResultSource,\n  OperationType,\n  RequestPolicy,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n  getOperationType,\n} from './utils';\n\n/** Configuration options passed when creating a new {@link Client}.\n *\n * @remarks\n * The `ClientOptions` are passed when creating a new {@link Client}, and\n * are used to instantiate the pipeline of {@link Exchange | Exchanges}, configure\n * options used to initialize {@link OperationContext | OperationContexts}, or to\n * change the general behaviour of the {@link Client}.\n */\nexport interface ClientOptions {\n  /** Target URL used by fetch exchanges to make GraphQL API requests to.\n   *\n   * @remarks\n   * This is the URL that fetch exchanges will call to make GraphQL API requests.\n   * This value is copied to {@link OperationContext.url}.\n   */\n  url: string;\n  /** Additional options used by fetch exchanges that'll be passed to the `fetch` call on API requests.\n   *\n   * @remarks\n   * The options in this object or an object returned by a callback function will be merged into the\n   * {@link RequestInit} options passed to the `fetch` call.\n   *\n   * Hint: If you're trying to implement more complex changes per {@link Operation}, it's worth considering\n   * to use the {@link mapExchange} instead, which allows you to change `Operation`s and `OperationResult`s.\n   *\n   * Hint: If you're trying to use this as a function for authentication, consider checking out\n   * `@urql/exchange-auth` instead, which allows you to handle refresh auth flows, and more\n   * complex auth flows.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch} for a description of this object.\n   */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** A `fetch` function polyfill used by fetch exchanges to make API calls.\n   *\n   * @remarks\n   * This is the fetch polyfill used by any fetch exchange to make an API request. By default, when this\n   * option isn't set, any fetch exchange will attempt to use the globally available `fetch` function\n   * to make a request instead.\n   *\n   * It's recommended to only pass a polyfill, if any of the environments you're running the {@link Client}\n   * in don't support the Fetch API natively.\n   *\n   * Hint: If you're using the \"Incremental Delivery\" multipart spec, for instance with `@defer` directives,\n   * you're better off using the native `fetch` function, or must ensure that your polyfill supports streamed\n   * results. However, a \"Streaming requests unsupported\" error will be thrown, to let you know that your `fetch`\n   * API doesn't support incrementally streamed responses, if this mode is used.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n   */\n  fetch?: typeof fetch;\n  /** Allows a subscription to be executed using a `fetch` API request.\n   *\n   * @remarks\n   * If your API supports the `text/event-stream` and/or `multipart/mixed` response protocol, and you use\n   * this protocol to handle subscriptions, then you may switch this flag to `true`.\n   *\n   * This means you won’t have to create a {@link subscriptionExchange} to handle subscriptions with an\n   * external transport, and will instead be able to use GraphQL over HTTP transports.\n   */\n  fetchSubscriptions?: boolean;\n  /** A list of `Exchange`s that will be used to create the `Client`'s execution pipeline.\n   *\n   * @remarks\n   * The {@link Client} accepts and composes a list of {@link Exchange | Exchanges} into an “exchange pipeline”\n   * which receive a stream of {@link Operation | Operations} the `Client` wishes to execute, and return a stream\n   * of {@link OperationResult | OperationResults}.\n   *\n   * This is the basis for how `urql` handles GraphQL operations, and exchanges handle the creation, execution,\n   * and control flow of exchanges for the `Client`.\n   *\n   * To easily get started you should consider using the {@link dedupExchange}, {@link cacheExchange} and {@link fetchExchange}\n   * these are all exported from the core package.\n   *\n   * @see {@link https://urql.dev/goto/docs/architecture/#the-client-and-exchanges} for more information\n   * on what `Exchange`s are and how they work.\n   */\n  exchanges: Exchange[];\n  /** A configuration flag indicating whether support for \"Suspense\" is activated.\n   *\n   * @remarks\n   * This configuration flag is only relevant for using `urql` with the React or Preact bindings.\n   * When activated it allows `useQuery` to \"suspend\" instead of returning a loading state, which\n   * will stop updates in a querying component and instead cascade\n   * to a higher suspense boundary for a loading state.\n   *\n   * Hint: While, when this option is enabled, by default all `useQuery` hooks will suspense, you can\n   * disable Suspense selectively for each hook.\n   *\n   * @see {@link https://beta.reactjs.org/blog/2022/03/29/react-v18#new-suspense-features} for more information on React Suspense.\n   */\n  suspense?: boolean;\n  /** The request and caching strategy that all `Operation`s on this `Client` will use by default.\n   *\n   * @remarks\n   * The {@link RequestPolicy} instructs cache exchanges how to use and treat their cached results.\n   * By default `cache-first` is set and used, which will use cache results, and only make an API request\n   * on a cache miss.\n   *\n   * The `requestPolicy` can be overriden per operation, since it's added to the {@link OperationContext},\n   * which allows you to change the policy per `Operation`, rather than changing it by default here.\n   *\n   * Hint: We don’t recommend changing this from the default `cache-first` option, unless you know what\n   * you‘re doing. Setting this to `cache-and-network` is not recommend and may not lead to the behaviour\n   * you expect. If you’re looking to always update your cache frequently, use `@urql/exchange-request-policy`\n   * instead.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Instructs fetch exchanges to use a GET request.\n   *\n   * @remarks\n   * This changes the {@link OperationContext.preferGetMethod} option, which tells fetch exchanges\n   * to use GET requests for queries instead of POST requests.\n   *\n   * When set to `true` or `'within-url-limit'`, built-in fetch exchanges will always attempt to send query\n   * operations as GET requests, unless the resulting URL exceeds a length of 2,048 characters.\n   * If you want to bypass this restriction, set this option to `'force'` instead, to always send GET.\n   * requests for queries.\n   */\n  preferGetMethod?: boolean | 'force' | 'within-url-limit';\n  /** Instructs the `Client` to remove `__typename` properties on all results.\n   *\n   * @deprecated Not recommended over modelling inputs manually (See #3299)\n   *\n   * @remarks\n   * By default, cache exchanges will alter your GraphQL documents to request `__typename` fields\n   * for all selections. However, this means that your GraphQL data will now contain `__typename` fields you\n   * didn't ask for. This is why the {@link Client} supports “masking” this field by marking it\n   * as non-enumerable via this option.\n   *\n   * Only use this option if you absolutely have to. It's popular to model mutation inputs in\n   * GraphQL schemas after the object types they modify, and if you're using this option to make\n   * it possible to directly pass objects from results as inputs to your mutation variables, it's\n   * more performant and idomatic to instead create a new input object.\n   *\n   * Hint: With `@urql/exchange-graphcache` you will never need this option, as it selects fields on\n   * the client-side according to which fields you specified, rather than the fields it modified.\n   *\n   * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n   * on typename introspection via the `__typename` field.\n   */\n  maskTypename?: boolean;\n}\n\n/** The `Client` is the central hub for your GraphQL operations and holds `urql`'s state.\n *\n * @remarks\n * The `Client` manages your active GraphQL operations and their state, and contains the\n * {@link Exchange} pipeline to execute your GraphQL operations.\n *\n * It contains methods that allow you to execute GraphQL operations manually, but the `Client`\n * is also interacted with by bindings (for React, Preact, Vue, Svelte, etc) to execute GraphQL\n * operations.\n *\n * While {@link Exchange | Exchanges} are ultimately responsible for the control flow of operations,\n * sending API requests, and caching, the `Client` still has the important responsibility for\n * creating operations, managing consumers of active operations, sharing results for operations,\n * and more tasks as a “central hub”.\n *\n * @see {@link https://urql.dev/goto/docs/architecture/#requests-and-operations-on-the-client} for more information\n * on what the `Client` is and does.\n */\nexport interface Client {\n  new (options: ClientOptions): Client;\n\n  /** Exposes the stream of `Operation`s that is passed to the `Exchange` pipeline.\n   *\n   * @remarks\n   * This is a Wonka {@link Source} that issues the {@link Operation | Operations} going into\n   * the exchange pipeline.\n   * @internal\n   */\n  operations$: Source<Operation>;\n\n  /** Flag indicating whether support for “Suspense” is activated.\n   *\n   * @remarks\n   * This flag indicates whether support for “Suspense” has been activated via the\n   * {@link ClientOptions.suspense} flag.\n   *\n   * When this is enabled, the {@link Client} itself doesn’t function any differently, and the flag\n   * only serves as an instructions for the React/Preact bindings to change their behaviour.\n   *\n   * @see {@link ClientOptions.suspense} for more information.\n   * @internal\n   */\n  suspense: boolean;\n\n  /** Dispatches an `Operation` to the `Exchange` pipeline, if this `Operation` is active.\n   *\n   * @remarks\n   * This method is frequently used in {@link Exchange | Exchanges}, for instance caches, to reexecute\n   * an operation. It’s often either called because an `Operation` will need to be queried against the\n   * cache again, if a cache result has changed or been invalidated, or it’s called with an {@link Operation}'s\n   * {@link RequestPolicy} set to `network-only` to issue a network request.\n   *\n   * This method will only dispatch an {@link Operation} if it has active consumers, meaning,\n   * active subscribers to the sources of {@link OperationResult}. For instance, if no bindings\n   * (e.g. `useQuery`) is subscribed to the `Operation`, then `reexecuteOperation` will do nothing.\n   *\n   * All operations are put onto a queue and executed after a micro-tick. The queue of operations is\n   * emptied eagerly and synchronously, similar to a trampoline scheduler.\n   */\n  reexecuteOperation(operation: Operation): void;\n\n  /** Subscribe method to add an event listener to debug events.\n   *\n   * @param onEvent - A callback called with new debug events, each time an `Exchange` issues them.\n   * @returns A Wonka {@link Subscription} which is used to optionally terminate the event listener.\n   *\n   * @remarks\n   * This is a method that's only available in development, and allows the `urql-devtools` to receive\n   * to debug events that are issued by exchanges, giving the devtools more information about the flow\n   * and execution of {@link Operation | Operations}.\n   *\n   * @see {@link DebugEventTypes} for a description of all debug events.\n   * @internal\n   */\n  subscribeToDebugTarget?(onEvent: (event: DebugEvent) => void): Subscription;\n\n  /** Creates an `Operation` from a `GraphQLRequest` and optionally, overriding `OperationContext` options.\n   *\n   * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n   * @param request - A {@link GraphQLRequest} created prior to calling this method.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns An {@link Operation} created from the parameters.\n   *\n   * @remarks\n   * This method is expected to be called with a `kind` set to the `OperationType` of the GraphQL operation.\n   * In development, this is enforced by checking that the GraphQL document's operation matches this `kind`.\n   *\n   * Hint: While bindings will use this method combined with {@link Client.executeRequestOperation}, if\n   * you’re executing operations manually, you can use one of the other convenience methods instead.\n   *\n   * @see {@link Client.executeRequestOperation} for the method used to execute operations.\n   * @see {@link createRequest} which creates a `GraphQLRequest` from a `DocumentNode` and variables.\n   */\n  createRequestOperation<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Operation<Data, Variables>;\n\n  /** Creates a `Source` that executes the `Operation` and issues `OperationResult`s for this `Operation`.\n   *\n   * @param operation - {@link Operation} that will be executed.\n   * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults} for the passed `Operation`.\n   *\n   * @remarks\n   * The {@link Operation} will be dispatched to the pipeline of {@link Exchange | Exchanges} when\n   * subscribing to the returned {@link Source}, which issues {@link OperationResult | OperationResults}\n   * belonging to this `Operation`.\n   *\n   * Internally, {@link OperationResult | OperationResults} are filtered and deliverd to this source by\n   * comparing the {@link Operation.key} on the operation and the {@link OperationResult.operation}.\n   * For mutations, the {@link OperationContext._instance | `OperationContext._instance`} will additionally be compared, since two mutations\n   * with, even given the same variables, will have two distinct results and will be executed separately.\n   *\n   * The {@link Client} dispatches the {@link Operation} when we subscribe to the returned {@link Source}\n   * and will from then on consider the `Operation` as “active” until we unsubscribe. When all consumers unsubscribe\n   * from an `Operation` and it becomes “inactive” a `teardown` signal will be dispatched to the\n   * {@link Exchange | Exchanges}.\n   *\n   * Hint: While bindings will use this method, if you’re executing operations manually, you can use one\n   * of the other convenience methods instead, like {@link Client.executeQuery} et al.\n   */\n  executeRequestOperation<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    operation: Operation<Data, Variables>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL query operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the query operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link OperationResultSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.query` method is useful to programmatically create and issue a GraphQL query operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Since it returns a {@link OperationResultSource} it may be chained with a `toPromise()` call to only\n   * await a single result in an async function.\n   *\n   * Hint: This is the recommended way to create queries programmatically when not using the bindings,\n   * or when you’re trying to get a single, promisified result.\n   *\n   * @example\n   * ```ts\n   * const getBookQuery = gql`\n   *   query GetBook($id: ID!) {\n   *     book(id: $id) {\n   *       id\n   *       name\n   *       author {\n   *         name\n   *       }\n   *     }\n   *   }\n   * `;\n   *\n   * async function getBook(id) {\n   *   const result = await client.query(getBookQuery, { id }).toPromise();\n   *   if (result.error) {\n   *     throw result.error;\n   *   }\n   *\n   *   return result.data.book;\n   * }\n   * ```\n   */\n  query<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Returns the first synchronous result a `Client` provides for a given operation.\n   *\n   * @param query - a GraphQL document containing the query operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns An {@link OperationResult} if one became available synchronously or `null`.\n   *\n   * @remarks\n   * The `Client.readQuery` method returns a result synchronously or defaults to `null`. This is useful\n   * as it limits the result for a query operation to whatever the cache {@link Exchange} of a {@link Client}\n   * had stored and available at that moment.\n   *\n   * In `urql`, it's expected that cache exchanges return their results synchronously. The bindings\n   * and this method exploit this by using synchronous results, like these, to check what data is already\n   * in the cache.\n   *\n   * This method is similar to what all bindings do to synchronously provide the initial state for queries,\n   * regardless of whether effects afterwards that subscribe to the query operation update this state synchronously\n   * or asynchronously.\n   */\n  readQuery<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null;\n\n  /** Creates a `Source` that executes the GraphQL query operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeQuery` method is used to programmatically issue a GraphQL query operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.query} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeQuery<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL subscription operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the subscription operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A Wonka {@link Source} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.subscription` method is useful to programmatically create and issue a GraphQL subscription operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Hint: This is the recommended way to create subscriptions programmatically when not using the bindings.\n   *\n   * @example\n   * ```ts\n   * import { pipe, subscribe } from 'wonka';\n   *\n   * const getNewsSubscription = gql`\n   *   subscription GetNews {\n   *     breakingNews {\n   *       id\n   *       text\n   *       createdAt\n   *     }\n   *   }\n   * `;\n   *\n   * function subscribeToBreakingNews() {\n   *   const subscription = pipe(\n   *     client.subscription(getNewsSubscription, {}),\n   *     subscribe(result => {\n   *       if (result.data) {\n   *         console.log(result.data.breakingNews.text);\n   *       }\n   *     })\n   *   );\n   *\n   *   return subscription.unsubscribe;\n   * }\n   * ```\n   */\n  subscription<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL subscription operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeSubscription` method is used to programmatically issue a GraphQL subscription operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.subscription} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeSubscription<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL mutation operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the mutation operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.mutation` method is useful to programmatically create and issue a GraphQL mutation operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Since it returns a {@link PromisifiedSource} it may be chained with a `toPromise()` call to only\n   * await a single result in an async function. Since mutations will only typically issue one result,\n   * using this method is recommended.\n   *\n   * Hint: This is the recommended way to create mutations programmatically when not using the bindings,\n   * or when you’re trying to get a single, promisified result.\n   *\n   * @example\n   * ```ts\n   * const createPostMutation = gql`\n   *   mutation CreatePost($text: String!) {\n   *     createPost(text: $text) {\n   *       id\n   *       text\n   *     }\n   *   }\n   * `;\n   *\n   * async function createPost(text) {\n   *   const result = await client.mutation(createPostMutation, {\n   *     text,\n   *   }).toPromise();\n   *   if (result.error) {\n   *     throw result.error;\n   *   }\n   *\n   *   return result.data.createPost;\n   * }\n   * ```\n   */\n  mutation<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL mutation operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeMutation` method is used to programmatically issue a GraphQL mutation operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.mutation} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeMutation<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n}\n\nexport const Client: new (opts: ClientOptions) => Client = function Client(\n  this: Client | {},\n  opts: ClientOptions\n) {\n  if (process.env.NODE_ENV !== 'production' && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n\n  let ids = 0;\n\n  const replays = new Map<number, OperationResult>();\n  const active: Map<number, Source<OperationResult>> = new Map();\n  const dispatched = new Set<number>();\n  const queue: Operation[] = [];\n\n  const baseOpts = {\n    url: opts.url,\n    fetchSubscriptions: opts.fetchSubscriptions,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    preferGetMethod: opts.preferGetMethod,\n    requestPolicy: opts.requestPolicy || 'cache-first',\n  };\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  const operations = makeSubject<Operation>();\n\n  function nextOperation(operation: Operation) {\n    if (\n      operation.kind === 'mutation' ||\n      operation.kind === 'teardown' ||\n      !dispatched.has(operation.key)\n    ) {\n      if (operation.kind === 'teardown') {\n        dispatched.delete(operation.key);\n      } else if (operation.kind !== 'mutation') {\n        dispatched.add(operation.key);\n      }\n      operations.next(operation);\n    }\n  }\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  let isOperationBatchActive = false;\n  function dispatchOperation(operation?: Operation | void) {\n    if (operation) nextOperation(operation);\n\n    if (!isOperationBatchActive) {\n      isOperationBatchActive = true;\n      while (isOperationBatchActive && (operation = queue.shift()))\n        nextOperation(operation);\n      isOperationBatchActive = false;\n    }\n  }\n\n  /** Defines how result streams are created */\n  const makeResultSource = (operation: Operation) => {\n    let result$ = pipe(\n      results$,\n      // Filter by matching key (or _instance if it’s set)\n      filter(\n        (res: OperationResult) =>\n          res.operation.kind === operation.kind &&\n          res.operation.key === operation.key &&\n          (!res.operation.context._instance ||\n            res.operation.context._instance === operation.context._instance)\n      ),\n      // End the results stream when an active teardown event is sent\n      takeUntil(\n        pipe(\n          operations.source,\n          filter(op => op.kind === 'teardown' && op.key === operation.key)\n        )\n      )\n    );\n\n    // Mask typename properties if the option for it is turned on\n    if (opts.maskTypename) {\n      result$ = pipe(\n        result$,\n        map(res => ({ ...res, data: maskTypename(res.data, true) }))\n      );\n    }\n\n    if (operation.kind !== 'query') {\n      // Interrupt subscriptions and mutations when they have no more results\n      result$ = pipe(\n        result$,\n        takeWhile(result => !!result.hasNext, true)\n      );\n    } else {\n      result$ = pipe(\n        result$,\n        // Add `stale: true` flag when a new operation is sent for queries\n        switchMap(result => {\n          const value$ = fromValue(result);\n          return result.stale || result.hasNext\n            ? value$\n            : merge([\n                value$,\n                pipe(\n                  operations.source,\n                  filter(op => op.key === operation.key),\n                  take(1),\n                  map(() => {\n                    result.stale = true;\n                    return result;\n                  })\n                ),\n              ]);\n        })\n      );\n    }\n\n    if (operation.kind !== 'mutation') {\n      result$ = pipe(\n        result$,\n        // Store replay result\n        onPush(result => {\n          if (result.stale) {\n            // If the current result has queued up an operation of the same\n            // key, then `stale` refers to it\n            for (const operation of queue) {\n              if (operation.key === result.operation.key) {\n                dispatched.delete(operation.key);\n                break;\n              }\n            }\n          } else if (!result.hasNext) {\n            dispatched.delete(operation.key);\n          }\n          replays.set(operation.key, result);\n        }),\n        // Cleanup active states on end of source\n        onEnd(() => {\n          // Delete the active operation handle\n          dispatched.delete(operation.key);\n          replays.delete(operation.key);\n          active.delete(operation.key);\n          // Interrupt active queue\n          isOperationBatchActive = false;\n          // Delete all queued up operations of the same key on end\n          for (let i = queue.length - 1; i >= 0; i--)\n            if (queue[i].key === operation.key) queue.splice(i, 1);\n          // Dispatch a teardown signal for the stopped operation\n          nextOperation(\n            makeOperation('teardown', operation, operation.context)\n          );\n        })\n      );\n    } else {\n      result$ = pipe(\n        result$,\n        // Send mutation operation on start\n        onStart(() => {\n          nextOperation(operation);\n        })\n      );\n    }\n\n    return share(result$);\n  };\n\n  const instance: Client =\n    this instanceof Client ? this : Object.create(Client.prototype);\n  const client: Client = Object.assign(instance, {\n    suspense: !!opts.suspense,\n    operations$: operations.source,\n\n    reexecuteOperation(operation: Operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'teardown') {\n        dispatchOperation(operation);\n      } else if (operation.kind === 'mutation' || active.has(operation.key)) {\n        let queued = false;\n        for (let i = 0; i < queue.length; i++)\n          queued = queued || queue[i].key === operation.key;\n        if (!queued) dispatched.delete(operation.key);\n        queue.push(operation);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n\n    createRequestOperation(kind, request, opts) {\n      if (!opts) opts = {};\n\n      let requestOperationType: string | undefined;\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        kind !== 'teardown' &&\n        (requestOperationType = getOperationType(request.query)) !== kind\n      ) {\n        throw new Error(\n          `Expected operation of type \"${kind}\" but found \"${requestOperationType}\"`\n        );\n      }\n\n      return makeOperation(kind, request, {\n        _instance:\n          kind === 'mutation'\n            ? ((ids = (ids + 1) | 0) as OperationInstance)\n            : undefined,\n        ...baseOpts,\n        ...opts,\n        requestPolicy: opts.requestPolicy || baseOpts.requestPolicy,\n        suspense: opts.suspense || (opts.suspense !== false && client.suspense),\n      });\n    },\n\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return withPromise(makeResultSource(operation));\n      }\n\n      return withPromise(\n        lazy<OperationResult>(() => {\n          let source = active.get(operation.key);\n          if (!source) {\n            active.set(operation.key, (source = makeResultSource(operation)));\n          }\n\n          source = pipe(\n            source,\n            onStart(() => {\n              dispatchOperation(operation);\n            })\n          );\n\n          const replay = replays.get(operation.key);\n          if (\n            operation.kind === 'query' &&\n            replay &&\n            (replay.stale || replay.hasNext)\n          ) {\n            return pipe(\n              merge([\n                source,\n                pipe(\n                  fromValue(replay),\n                  filter(replay => replay === replays.get(operation.key))\n                ),\n              ]),\n              switchMap(fromValue)\n            );\n          } else {\n            return source;\n          }\n        })\n      );\n    },\n\n    executeQuery(query, opts) {\n      const operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    executeSubscription(query, opts) {\n      const operation = client.createRequestOperation(\n        'subscription',\n        query,\n        opts\n      );\n      return client.executeRequestOperation(operation);\n    },\n\n    executeMutation(query, opts) {\n      const operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    readQuery(query, variables, context) {\n      let result: OperationResult | null = null;\n\n      pipe(\n        client.query(query, variables, context),\n        subscribe(res => {\n          result = res;\n        })\n      ).unsubscribe();\n\n      return result;\n    },\n\n    query(query, variables, context) {\n      return client.executeQuery(createRequest(query, variables), context);\n    },\n\n    subscription(query, variables, context) {\n      return client.executeSubscription(\n        createRequest(query, variables),\n        context\n      );\n    },\n\n    mutation(query, variables, context) {\n      return client.executeMutation(createRequest(query, variables), context);\n    },\n  } as Client);\n\n  let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n  if (process.env.NODE_ENV !== 'production') {\n    const { next, source } = makeSubject<DebugEvent>();\n    client.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n      pipe(source, subscribe(onEvent));\n    dispatchDebug = next as ExchangeInput['dispatchDebug'];\n  }\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  const composedExchange = composeExchanges(opts.exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  const results$ = share(\n    composedExchange({\n      client,\n      dispatchDebug,\n      forward: fallbackExchange({ dispatchDebug }),\n    })(operations.source)\n  );\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  pipe(results$, publish);\n\n  return client;\n} as any;\n\n/** Accepts `ClientOptions` and creates a `Client`.\n * @param opts - A {@link ClientOptions} objects with options for the `Client`.\n * @returns A {@link Client} instantiated with `opts`.\n */\nexport const createClient = Client as any as (opts: ClientOptions) => Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}