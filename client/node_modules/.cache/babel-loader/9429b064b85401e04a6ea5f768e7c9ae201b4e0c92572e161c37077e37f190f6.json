{"ast":null,"code":"var e = {\n  NAME: \"Name\",\n  DOCUMENT: \"Document\",\n  OPERATION_DEFINITION: \"OperationDefinition\",\n  VARIABLE_DEFINITION: \"VariableDefinition\",\n  SELECTION_SET: \"SelectionSet\",\n  FIELD: \"Field\",\n  ARGUMENT: \"Argument\",\n  FRAGMENT_SPREAD: \"FragmentSpread\",\n  INLINE_FRAGMENT: \"InlineFragment\",\n  FRAGMENT_DEFINITION: \"FragmentDefinition\",\n  VARIABLE: \"Variable\",\n  INT: \"IntValue\",\n  FLOAT: \"FloatValue\",\n  STRING: \"StringValue\",\n  BOOLEAN: \"BooleanValue\",\n  NULL: \"NullValue\",\n  ENUM: \"EnumValue\",\n  LIST: \"ListValue\",\n  OBJECT: \"ObjectValue\",\n  OBJECT_FIELD: \"ObjectField\",\n  DIRECTIVE: \"Directive\",\n  NAMED_TYPE: \"NamedType\",\n  LIST_TYPE: \"ListType\",\n  NON_NULL_TYPE: \"NonNullType\"\n};\nvar r = {\n  QUERY: \"query\",\n  MUTATION: \"mutation\",\n  SUBSCRIPTION: \"subscription\"\n};\nclass GraphQLError extends Error {\n  constructor(e, r, i, n, a, t, o) {\n    super(e);\n    this.name = \"GraphQLError\";\n    this.message = e;\n    if (a) {\n      this.path = a;\n    }\n    if (r) {\n      this.nodes = Array.isArray(r) ? r : [r];\n    }\n    if (i) {\n      this.source = i;\n    }\n    if (n) {\n      this.positions = n;\n    }\n    if (t) {\n      this.originalError = t;\n    }\n    var l = o;\n    if (!l && t) {\n      var u = t.extensions;\n      if (u && \"object\" == typeof u) {\n        l = u;\n      }\n    }\n    this.extensions = l || {};\n  }\n  toJSON() {\n    return {\n      ...this,\n      message: this.message\n    };\n  }\n  toString() {\n    return this.message;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n}\nvar i;\nvar n;\nfunction error(e) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${n} in ${e}`);\n}\nfunction advance(e) {\n  e.lastIndex = n;\n  if (e.test(i)) {\n    return i.slice(n, n = e.lastIndex);\n  }\n}\nvar a = / +(?=[^\\s])/y;\nfunction blockString(e) {\n  var r = e.split(\"\\n\");\n  var i = \"\";\n  var n = 0;\n  var t = 0;\n  var o = r.length - 1;\n  for (var l = 0; l < r.length; l++) {\n    a.lastIndex = 0;\n    if (a.test(r[l])) {\n      if (l && (!n || a.lastIndex < n)) {\n        n = a.lastIndex;\n      }\n      t = t || l;\n      o = l;\n    }\n  }\n  for (var u = t; u <= o; u++) {\n    if (u !== t) {\n      i += \"\\n\";\n    }\n    i += r[u].slice(n).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return i;\n}\nfunction ignored() {\n  for (var e = 0 | i.charCodeAt(n++); 9 === e || 10 === e || 13 === e || 32 === e || 35 === e || 44 === e || 65279 === e; e = 0 | i.charCodeAt(n++)) {\n    if (35 === e) {\n      while (10 !== (e = i.charCodeAt(n++)) && 13 !== e) {}\n    }\n  }\n  n--;\n}\nvar t = /[_A-Za-z]\\w*/y;\nfunction name() {\n  var e;\n  if (e = advance(t)) {\n    return {\n      kind: \"Name\",\n      value: e\n    };\n  }\n}\nvar o = /(?:null|true|false)/y;\nvar l = /\\$[_A-Za-z]\\w*/y;\nvar u = /-?\\d+/y;\nvar v = /(?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+/y;\nvar d = /\\\\/g;\nvar s = /\"\"\"(?:\"\"\"|(?:[\\s\\S]*?[^\\\\])\"\"\")/y;\nvar c = /\"(?:\"|[^\\r\\n]*?[^\\\\]\")/y;\nfunction value(e) {\n  var r;\n  var a;\n  if (a = advance(o)) {\n    r = \"null\" === a ? {\n      kind: \"NullValue\"\n    } : {\n      kind: \"BooleanValue\",\n      value: \"true\" === a\n    };\n  } else if (!e && (a = advance(l))) {\n    r = {\n      kind: \"Variable\",\n      name: {\n        kind: \"Name\",\n        value: a.slice(1)\n      }\n    };\n  } else if (a = advance(u)) {\n    var f = a;\n    if (a = advance(v)) {\n      r = {\n        kind: \"FloatValue\",\n        value: f + a\n      };\n    } else {\n      r = {\n        kind: \"IntValue\",\n        value: f\n      };\n    }\n  } else if (a = advance(t)) {\n    r = {\n      kind: \"EnumValue\",\n      value: a\n    };\n  } else if (a = advance(s)) {\n    r = {\n      kind: \"StringValue\",\n      value: blockString(a.slice(3, -3)),\n      block: !0\n    };\n  } else if (a = advance(c)) {\n    r = {\n      kind: \"StringValue\",\n      value: d.test(a) ? JSON.parse(a) : a.slice(1, -1),\n      block: !1\n    };\n  } else if (r = function list(e) {\n    var r;\n    if (91 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      var a = [];\n      while (r = value(e)) {\n        a.push(r);\n      }\n      if (93 !== i.charCodeAt(n++)) {\n        throw error(\"ListValue\");\n      }\n      ignored();\n      return {\n        kind: \"ListValue\",\n        values: a\n      };\n    }\n  }(e) || function object(e) {\n    if (123 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      var r = [];\n      var a;\n      while (a = name()) {\n        ignored();\n        if (58 !== i.charCodeAt(n++)) {\n          throw error(\"ObjectField\");\n        }\n        ignored();\n        var t = value(e);\n        if (!t) {\n          throw error(\"ObjectField\");\n        }\n        r.push({\n          kind: \"ObjectField\",\n          name: a,\n          value: t\n        });\n      }\n      if (125 !== i.charCodeAt(n++)) {\n        throw error(\"ObjectValue\");\n      }\n      ignored();\n      return {\n        kind: \"ObjectValue\",\n        fields: r\n      };\n    }\n  }(e)) {\n    return r;\n  }\n  ignored();\n  return r;\n}\nfunction arguments_(e) {\n  var r = [];\n  ignored();\n  if (40 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var a;\n    while (a = name()) {\n      ignored();\n      if (58 !== i.charCodeAt(n++)) {\n        throw error(\"Argument\");\n      }\n      ignored();\n      var t = value(e);\n      if (!t) {\n        throw error(\"Argument\");\n      }\n      r.push({\n        kind: \"Argument\",\n        name: a,\n        value: t\n      });\n    }\n    if (!r.length || 41 !== i.charCodeAt(n++)) {\n      throw error(\"Argument\");\n    }\n    ignored();\n  }\n  return r;\n}\nfunction directives(e) {\n  var r = [];\n  ignored();\n  while (64 === i.charCodeAt(n)) {\n    n++;\n    var a = name();\n    if (!a) {\n      throw error(\"Directive\");\n    }\n    ignored();\n    r.push({\n      kind: \"Directive\",\n      name: a,\n      arguments: arguments_(e)\n    });\n  }\n  return r;\n}\nfunction field() {\n  var e = name();\n  if (e) {\n    ignored();\n    var r;\n    if (58 === i.charCodeAt(n)) {\n      n++;\n      ignored();\n      r = e;\n      if (!(e = name())) {\n        throw error(\"Field\");\n      }\n      ignored();\n    }\n    return {\n      kind: \"Field\",\n      alias: r,\n      name: e,\n      arguments: arguments_(!1),\n      directives: directives(!1),\n      selectionSet: selectionSet()\n    };\n  }\n}\nfunction type() {\n  var e;\n  ignored();\n  if (91 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var r = type();\n    if (!r || 93 !== i.charCodeAt(n++)) {\n      throw error(\"ListType\");\n    }\n    e = {\n      kind: \"ListType\",\n      type: r\n    };\n  } else if (e = name()) {\n    e = {\n      kind: \"NamedType\",\n      name: e\n    };\n  } else {\n    throw error(\"NamedType\");\n  }\n  ignored();\n  if (33 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    return {\n      kind: \"NonNullType\",\n      type: e\n    };\n  } else {\n    return e;\n  }\n}\nvar f = /on/y;\nfunction typeCondition() {\n  if (advance(f)) {\n    ignored();\n    var e = name();\n    if (!e) {\n      throw error(\"NamedType\");\n    }\n    ignored();\n    return {\n      kind: \"NamedType\",\n      name: e\n    };\n  }\n}\nvar p = /\\.\\.\\./y;\nfunction fragmentSpread() {\n  if (advance(p)) {\n    ignored();\n    var e = n;\n    var r;\n    if ((r = name()) && \"on\" !== r.value) {\n      return {\n        kind: \"FragmentSpread\",\n        name: r,\n        directives: directives(!1)\n      };\n    } else {\n      n = e;\n      var i = typeCondition();\n      var a = directives(!1);\n      var t = selectionSet();\n      if (!t) {\n        throw error(\"InlineFragment\");\n      }\n      return {\n        kind: \"InlineFragment\",\n        typeCondition: i,\n        directives: a,\n        selectionSet: t\n      };\n    }\n  }\n}\nfunction selectionSet() {\n  var e;\n  ignored();\n  if (123 === i.charCodeAt(n)) {\n    n++;\n    ignored();\n    var r = [];\n    while (e = fragmentSpread() || field()) {\n      r.push(e);\n    }\n    if (!r.length || 125 !== i.charCodeAt(n++)) {\n      throw error(\"SelectionSet\");\n    }\n    ignored();\n    return {\n      kind: \"SelectionSet\",\n      selections: r\n    };\n  }\n}\nvar m = /fragment/y;\nfunction fragmentDefinition() {\n  if (advance(m)) {\n    ignored();\n    var e = name();\n    if (!e) {\n      throw error(\"FragmentDefinition\");\n    }\n    ignored();\n    var r = typeCondition();\n    if (!r) {\n      throw error(\"FragmentDefinition\");\n    }\n    var i = directives(!1);\n    var n = selectionSet();\n    if (!n) {\n      throw error(\"FragmentDefinition\");\n    }\n    return {\n      kind: \"FragmentDefinition\",\n      name: e,\n      typeCondition: r,\n      directives: i,\n      selectionSet: n\n    };\n  }\n}\nvar g = /(?:query|mutation|subscription)/y;\nfunction operationDefinition() {\n  var e;\n  var r;\n  var a = [];\n  var t = [];\n  if (e = advance(g)) {\n    ignored();\n    r = name();\n    a = function variableDefinitions() {\n      var e;\n      var r = [];\n      ignored();\n      if (40 === i.charCodeAt(n)) {\n        n++;\n        ignored();\n        while (e = advance(l)) {\n          ignored();\n          if (58 !== i.charCodeAt(n++)) {\n            throw error(\"VariableDefinition\");\n          }\n          var a = type();\n          var t = void 0;\n          if (61 === i.charCodeAt(n)) {\n            n++;\n            ignored();\n            if (!(t = value(!0))) {\n              throw error(\"VariableDefinition\");\n            }\n          }\n          ignored();\n          r.push({\n            kind: \"VariableDefinition\",\n            variable: {\n              kind: \"Variable\",\n              name: {\n                kind: \"Name\",\n                value: e.slice(1)\n              }\n            },\n            type: a,\n            defaultValue: t,\n            directives: directives(!0)\n          });\n        }\n        if (41 !== i.charCodeAt(n++)) {\n          throw error(\"VariableDefinition\");\n        }\n        ignored();\n      }\n      return r;\n    }();\n    t = directives(!1);\n  }\n  var o = selectionSet();\n  if (o) {\n    return {\n      kind: \"OperationDefinition\",\n      operation: e || \"query\",\n      name: r,\n      variableDefinitions: a,\n      directives: t,\n      selectionSet: o\n    };\n  }\n}\nfunction parse(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return function document() {\n    var e;\n    ignored();\n    var r = [];\n    while (e = fragmentDefinition() || operationDefinition()) {\n      r.push(e);\n    }\n    return {\n      kind: \"Document\",\n      definitions: r\n    };\n  }();\n}\nfunction parseValue(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  ignored();\n  var a = value(!1);\n  if (!a) {\n    throw error(\"ValueNode\");\n  }\n  return a;\n}\nfunction parseType(e, r) {\n  i = \"string\" == typeof e.body ? e.body : e;\n  n = 0;\n  return type();\n}\nvar h = {};\nfunction visit(e, r) {\n  var i = [];\n  var n = [];\n  try {\n    var a = function traverse(e, a, t) {\n      var o = !1;\n      var l = r[e.kind] && r[e.kind].enter || r[e.kind] || r.enter;\n      var u = l && l.call(r, e, a, t, n, i);\n      if (!1 === u) {\n        return e;\n      } else if (null === u) {\n        return null;\n      } else if (u === h) {\n        throw h;\n      } else if (u && \"string\" == typeof u.kind) {\n        o = u !== e;\n        e = u;\n      }\n      if (t) {\n        i.push(t);\n      }\n      var v;\n      var d = {\n        ...e\n      };\n      for (var s in e) {\n        n.push(s);\n        var c = e[s];\n        if (Array.isArray(c)) {\n          var f = [];\n          for (var p = 0; p < c.length; p++) {\n            if (null != c[p] && \"string\" == typeof c[p].kind) {\n              i.push(e);\n              n.push(p);\n              v = traverse(c[p], p, c);\n              n.pop();\n              i.pop();\n              if (null == v) {\n                o = !0;\n              } else {\n                o = o || v !== c[p];\n                f.push(v);\n              }\n            }\n          }\n          c = f;\n        } else if (null != c && \"string\" == typeof c.kind) {\n          if (void 0 !== (v = traverse(c, s, e))) {\n            o = o || c !== v;\n            c = v;\n          }\n        }\n        n.pop();\n        if (o) {\n          d[s] = c;\n        }\n      }\n      if (t) {\n        i.pop();\n      }\n      var m = r[e.kind] && r[e.kind].leave || r.leave;\n      var g = m && m.call(r, e, a, t, n, i);\n      if (g === h) {\n        throw h;\n      } else if (void 0 !== g) {\n        return g;\n      } else if (void 0 !== u) {\n        return o ? d : u;\n      } else {\n        return o ? d : e;\n      }\n    }(e);\n    return void 0 !== a && !1 !== a ? a : e;\n  } catch (r) {\n    if (r !== h) {\n      throw r;\n    }\n    return e;\n  }\n}\nfunction printString(e) {\n  return JSON.stringify(e);\n}\nfunction printBlockString(e) {\n  return '\"\"\"\\n' + e.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\nvar hasItems = e => !(!e || !e.length);\nvar y = {\n  OperationDefinition(e) {\n    if (\"query\" === e.operation && !e.name && !hasItems(e.variableDefinitions) && !hasItems(e.directives)) {\n      return y.SelectionSet(e.selectionSet);\n    }\n    var r = e.operation;\n    if (e.name) {\n      r += \" \" + e.name.value;\n    }\n    if (hasItems(e.variableDefinitions)) {\n      if (!e.name) {\n        r += \" \";\n      }\n      r += \"(\" + e.variableDefinitions.map(y.VariableDefinition).join(\", \") + \")\";\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + y.SelectionSet(e.selectionSet);\n  },\n  VariableDefinition(e) {\n    var r = y.Variable(e.variable) + \": \" + print(e.type);\n    if (e.defaultValue) {\n      r += \" = \" + print(e.defaultValue);\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r;\n  },\n  Field(e) {\n    var r = (e.alias ? e.alias.value + \": \" : \"\") + e.name.value;\n    if (hasItems(e.arguments)) {\n      var i = e.arguments.map(y.Argument);\n      var n = r + \"(\" + i.join(\", \") + \")\";\n      r = n.length > 80 ? r + \"(\\n  \" + i.join(\"\\n\").replace(/\\n/g, \"\\n  \") + \"\\n)\" : n;\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return e.selectionSet ? r + \" \" + y.SelectionSet(e.selectionSet) : r;\n  },\n  StringValue: e => e.block ? printBlockString(e.value) : printString(e.value),\n  BooleanValue: e => \"\" + e.value,\n  NullValue: e => \"null\",\n  IntValue: e => e.value,\n  FloatValue: e => e.value,\n  EnumValue: e => e.value,\n  Name: e => e.value,\n  Variable: e => \"$\" + e.name.value,\n  ListValue: e => \"[\" + e.values.map(print).join(\", \") + \"]\",\n  ObjectValue: e => \"{\" + e.fields.map(y.ObjectField).join(\", \") + \"}\",\n  ObjectField: e => e.name.value + \": \" + print(e.value),\n  Document: e => hasItems(e.definitions) ? e.definitions.map(print).join(\"\\n\\n\") : \"\",\n  SelectionSet: e => \"{\\n  \" + e.selections.map(print).join(\"\\n\").replace(/\\n/g, \"\\n  \") + \"\\n}\",\n  Argument: e => e.name.value + \": \" + print(e.value),\n  FragmentSpread(e) {\n    var r = \"...\" + e.name.value;\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r;\n  },\n  InlineFragment(e) {\n    var r = \"...\";\n    if (e.typeCondition) {\n      r += \" on \" + e.typeCondition.name.value;\n    }\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + print(e.selectionSet);\n  },\n  FragmentDefinition(e) {\n    var r = \"fragment \" + e.name.value;\n    r += \" on \" + e.typeCondition.name.value;\n    if (hasItems(e.directives)) {\n      r += \" \" + e.directives.map(y.Directive).join(\" \");\n    }\n    return r + \" \" + print(e.selectionSet);\n  },\n  Directive(e) {\n    var r = \"@\" + e.name.value;\n    if (hasItems(e.arguments)) {\n      r += \"(\" + e.arguments.map(y.Argument).join(\", \") + \")\";\n    }\n    return r;\n  },\n  NamedType: e => e.name.value,\n  ListType: e => \"[\" + print(e.type) + \"]\",\n  NonNullType: e => print(e.type) + \"!\"\n};\nfunction print(e) {\n  return y[e.kind] ? y[e.kind](e) : \"\";\n}\nfunction valueFromASTUntyped(e, r) {\n  switch (e.kind) {\n    case \"NullValue\":\n      return null;\n    case \"IntValue\":\n      return parseInt(e.value, 10);\n    case \"FloatValue\":\n      return parseFloat(e.value);\n    case \"StringValue\":\n    case \"EnumValue\":\n    case \"BooleanValue\":\n      return e.value;\n    case \"ListValue\":\n      var i = [];\n      for (var n = 0, a = e.values; n < a.length; n += 1) {\n        i.push(valueFromASTUntyped(a[n], r));\n      }\n      return i;\n    case \"ObjectValue\":\n      var t = Object.create(null);\n      for (var o = 0, l = e.fields; o < l.length; o += 1) {\n        var u = l[o];\n        t[u.name.value] = valueFromASTUntyped(u.value, r);\n      }\n      return t;\n    case \"Variable\":\n      return r && r[e.name.value];\n  }\n}\nfunction valueFromTypeNode(e, r, i) {\n  if (\"Variable\" === e.kind) {\n    return i ? valueFromTypeNode(i[e.name.value], r, i) : void 0;\n  } else if (\"NonNullType\" === r.kind) {\n    return \"NullValue\" !== e.kind ? valueFromTypeNode(e, r, i) : void 0;\n  } else if (\"NullValue\" === e.kind) {\n    return null;\n  } else if (\"ListType\" === r.kind) {\n    if (\"ListValue\" === e.kind) {\n      var n = [];\n      for (var a = 0, t = e.values; a < t.length; a += 1) {\n        var o = valueFromTypeNode(t[a], r.type, i);\n        if (void 0 === o) {\n          return;\n        } else {\n          n.push(o);\n        }\n      }\n      return n;\n    }\n  } else if (\"NamedType\" === r.kind) {\n    switch (r.name.value) {\n      case \"Int\":\n      case \"Float\":\n      case \"String\":\n      case \"Bool\":\n        return r.name.value + \"Value\" === e.kind ? valueFromASTUntyped(e, i) : void 0;\n      default:\n        return valueFromASTUntyped(e, i);\n    }\n  }\n}\nexport { h as BREAK, GraphQLError, e as Kind, r as OperationTypeNode, parse, parseType, parseValue, print, printBlockString, printString, valueFromASTUntyped, valueFromTypeNode, visit };","map":{"version":3,"names":["e","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","r","QUERY","MUTATION","SUBSCRIPTION","GraphQLError","Error","constructor","i","n","a","t","o","name","message","path","nodes","Array","isArray","source","positions","originalError","l","u","extensions","toJSON","toString","Symbol","toStringTag","error","advance","lastIndex","test","slice","blockString","split","length","replace","ignored","charCodeAt","kind","value","v","d","s","c","f","block","JSON","parse","list","push","values","object","fields","arguments_","directives","arguments","field","alias","selectionSet","type","typeCondition","p","fragmentSpread","selections","m","fragmentDefinition","g","operationDefinition","variableDefinitions","variable","defaultValue","operation","body","document","definitions","parseValue","parseType","h","visit","traverse","enter","call","pop","leave","printString","stringify","printBlockString","hasItems","y","OperationDefinition","SelectionSet","map","VariableDefinition","join","Directive","Variable","print","Field","Argument","StringValue","BooleanValue","NullValue","IntValue","FloatValue","EnumValue","Name","ListValue","ObjectValue","ObjectField","Document","FragmentSpread","InlineFragment","FragmentDefinition","NamedType","ListType","NonNullType","valueFromASTUntyped","parseInt","parseFloat","Object","create","valueFromTypeNode"],"sources":["C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@0no-co\\graphql.web\\src\\kind.js","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@0no-co\\graphql.web\\src\\error.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@0no-co\\graphql.web\\src\\parser.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@0no-co\\graphql.web\\src\\visitor.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@0no-co\\graphql.web\\src\\printer.ts","C:\\Users\\91630\\Desktop\\Voting-system\\Voting-system\\Voting-Dapp-master\\client\\node_modules\\@0no-co\\graphql.web\\src\\values.ts"],"sourcesContent":["export const Kind = {\n  NAME: 'Name',\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  DIRECTIVE: 'Directive',\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n\n  /*\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',\n  */\n};\n\nexport const OperationTypeNode = {\n  QUERY: 'query',\n  MUTATION: 'mutation',\n  SUBSCRIPTION: 'subscription',\n};\n","import { Maybe, Extensions, Source } from './types';\nimport { ASTNode } from './ast';\n\nexport class GraphQLError extends Error {\n  readonly locations: ReadonlyArray<any> | undefined;\n  readonly path: ReadonlyArray<string | number> | undefined;\n  readonly nodes: ReadonlyArray<any> | undefined;\n  readonly source: Source | undefined;\n  readonly positions: ReadonlyArray<number> | undefined;\n  readonly originalError: Error | undefined;\n  readonly extensions: Extensions;\n\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<Error>,\n    extensions?: Maybe<Extensions>\n  ) {\n    super(message);\n\n    this.name = 'GraphQLError';\n    this.message = message;\n\n    if (path) this.path = path;\n    if (nodes) this.nodes = (Array.isArray(nodes) ? nodes : [nodes]) as ASTNode[];\n    if (source) this.source = source;\n    if (positions) this.positions = positions;\n    if (originalError) this.originalError = originalError;\n\n    let _extensions = extensions;\n    if (!_extensions && originalError) {\n      const originalExtensions = (originalError as any).extensions;\n      if (originalExtensions && typeof originalExtensions === 'object') {\n        _extensions = originalExtensions;\n      }\n    }\n\n    this.extensions = _extensions || {};\n  }\n\n  toJSON(): any {\n    return { ...this, message: this.message };\n  }\n\n  toString() {\n    return this.message;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n}\n","/**\n * This is a spec-compliant implementation of a GraphQL query language parser,\n * up-to-date with the October 2021 Edition. Unlike the reference implementation\n * in graphql.js it will only parse the query language, but not the schema\n * language.\n */\nimport { Kind, OperationTypeNode } from './kind';\nimport { GraphQLError } from './error';\nimport { Source } from './types';\nimport type * as ast from './ast';\n\nlet input: string;\nlet idx: number;\n\nfunction error(kind: string) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${idx} in ${kind}`);\n}\n\nfunction advance(pattern: RegExp) {\n  pattern.lastIndex = idx;\n  if (pattern.test(input)) {\n    const match = input.slice(idx, (idx = pattern.lastIndex));\n    return match;\n  }\n}\n\nconst leadingRe = / +(?=[^\\s])/y;\nfunction blockString(string: string) {\n  const lines = string.split('\\n');\n  let out = '';\n  let commonIndent = 0;\n  let firstNonEmptyLine = 0;\n  let lastNonEmptyLine = lines.length - 1;\n  for (let i = 0; i < lines.length; i++) {\n    leadingRe.lastIndex = 0;\n    if (leadingRe.test(lines[i])) {\n      if (i && (!commonIndent || leadingRe.lastIndex < commonIndent))\n        commonIndent = leadingRe.lastIndex;\n      firstNonEmptyLine = firstNonEmptyLine || i;\n      lastNonEmptyLine = i;\n    }\n  }\n  for (let i = firstNonEmptyLine; i <= lastNonEmptyLine; i++) {\n    if (i !== firstNonEmptyLine) out += '\\n';\n    out += lines[i].slice(commonIndent).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return out;\n}\n\n// Note: This is equivalent to: /(?:[\\s,]*|#[^\\n\\r]*)*/y\nfunction ignored() {\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    char === 9 /*'\\t'*/ ||\n    char === 10 /*'\\n'*/ ||\n    char === 13 /*'\\r'*/ ||\n    char === 32 /*' '*/ ||\n    char === 35 /*'#'*/ ||\n    char === 44 /*','*/ ||\n    char === 65279 /*'\\ufeff'*/;\n    char = input.charCodeAt(idx++) | 0\n  ) {\n    if (char === 35 /*'#'*/) while ((char = input.charCodeAt(idx++)) !== 10 && char !== 13);\n  }\n  idx--;\n}\n\nconst nameRe = /[_A-Za-z]\\w*/y;\nfunction name(): ast.NameNode | undefined {\n  let match: string | undefined;\n  if ((match = advance(nameRe))) {\n    return {\n      kind: 'Name' as Kind.NAME,\n      value: match,\n    };\n  }\n}\n\n// NOTE(Safari10 Quirk): This needs to be wrapped in a non-capturing group\nconst constRe = /(?:null|true|false)/y;\n\nconst variableRe = /\\$[_A-Za-z]\\w*/y;\nconst intRe = /-?\\d+/y;\n\n// NOTE(Safari10 Quirk): This cannot be further simplified\nconst floatPartRe = /(?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+/y;\n\nconst complexStringRe = /\\\\/g;\nconst blockStringRe = /\"\"\"(?:\"\"\"|(?:[\\s\\S]*?[^\\\\])\"\"\")/y;\nconst stringRe = /\"(?:\"|[^\\r\\n]*?[^\\\\]\")/y;\n\nfunction value(constant: true): ast.ConstValueNode;\nfunction value(constant: boolean): ast.ValueNode;\n\nfunction value(constant: boolean): ast.ValueNode | undefined {\n  let out: ast.ValueNode | undefined;\n  let match: string | undefined;\n  if ((match = advance(constRe))) {\n    out =\n      match === 'null'\n        ? {\n            kind: 'NullValue' as Kind.NULL,\n          }\n        : {\n            kind: 'BooleanValue' as Kind.BOOLEAN,\n            value: match === 'true',\n          };\n  } else if (!constant && (match = advance(variableRe))) {\n    out = {\n      kind: 'Variable' as Kind.VARIABLE,\n      name: {\n        kind: 'Name' as Kind.NAME,\n        value: match.slice(1),\n      },\n    };\n  } else if ((match = advance(intRe))) {\n    const intPart = match;\n    if ((match = advance(floatPartRe))) {\n      out = {\n        kind: 'FloatValue' as Kind.FLOAT,\n        value: intPart + match,\n      };\n    } else {\n      out = {\n        kind: 'IntValue' as Kind.INT,\n        value: intPart,\n      };\n    }\n  } else if ((match = advance(nameRe))) {\n    out = {\n      kind: 'EnumValue' as Kind.ENUM,\n      value: match,\n    };\n  } else if ((match = advance(blockStringRe))) {\n    out = {\n      kind: 'StringValue' as Kind.STRING,\n      value: blockString(match.slice(3, -3)),\n      block: true,\n    };\n  } else if ((match = advance(stringRe))) {\n    out = {\n      kind: 'StringValue' as Kind.STRING,\n      value: complexStringRe.test(match) ? (JSON.parse(match) as string) : match.slice(1, -1),\n      block: false,\n    };\n  } else if ((out = list(constant) || object(constant))) {\n    return out;\n  }\n\n  ignored();\n  return out;\n}\n\nfunction list(constant: boolean): ast.ListValueNode | undefined {\n  let match: ast.ValueNode | undefined;\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    idx++;\n    ignored();\n    const values: ast.ValueNode[] = [];\n    while ((match = value(constant))) values.push(match);\n    if (input.charCodeAt(idx++) !== 93 /*']'*/) throw error('ListValue');\n    ignored();\n    return {\n      kind: 'ListValue' as Kind.LIST,\n      values,\n    };\n  }\n}\n\nfunction object(constant: boolean): ast.ObjectValueNode | undefined {\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    const fields: ast.ObjectFieldNode[] = [];\n    let _name: ast.NameNode | undefined;\n    while ((_name = name())) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('ObjectField' as Kind.OBJECT_FIELD);\n      ignored();\n      const _value = value(constant);\n      if (!_value) throw error('ObjectField');\n      fields.push({\n        kind: 'ObjectField' as Kind.OBJECT_FIELD,\n        name: _name,\n        value: _value,\n      });\n    }\n    if (input.charCodeAt(idx++) !== 125 /*'}'*/) throw error('ObjectValue');\n    ignored();\n    return {\n      kind: 'ObjectValue' as Kind.OBJECT,\n      fields,\n    };\n  }\n}\n\nfunction arguments_(constant: boolean): ast.ArgumentNode[] {\n  const args: ast.ArgumentNode[] = [];\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    idx++;\n    ignored();\n    let _name: ast.NameNode | undefined;\n    while ((_name = name())) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('Argument');\n      ignored();\n      const _value = value(constant);\n      if (!_value) throw error('Argument');\n      args.push({\n        kind: 'Argument' as Kind.ARGUMENT,\n        name: _name,\n        value: _value,\n      });\n    }\n    if (!args.length || input.charCodeAt(idx++) !== 41 /*')'*/) throw error('Argument');\n    ignored();\n  }\n  return args;\n}\n\nfunction directives(constant: true): ast.ConstDirectiveNode[];\nfunction directives(constant: boolean): ast.DirectiveNode[];\n\nfunction directives(constant: boolean): ast.DirectiveNode[] {\n  const directives: ast.DirectiveNode[] = [];\n  ignored();\n  while (input.charCodeAt(idx) === 64 /*'@'*/) {\n    idx++;\n    const _name = name();\n    if (!_name) throw error('Directive');\n    ignored();\n    directives.push({\n      kind: 'Directive' as Kind.DIRECTIVE,\n      name: _name,\n      arguments: arguments_(constant),\n    });\n  }\n  return directives;\n}\n\nfunction field(): ast.FieldNode | undefined {\n  let _name = name();\n  if (_name) {\n    ignored();\n    let _alias: ast.NameNode | undefined;\n    if (input.charCodeAt(idx) === 58 /*':'*/) {\n      idx++;\n      ignored();\n      _alias = _name;\n      _name = name();\n      if (!_name) throw error('Field');\n      ignored();\n    }\n    return {\n      kind: 'Field' as Kind.FIELD,\n      alias: _alias,\n      name: _name,\n      arguments: arguments_(false),\n      directives: directives(false),\n      selectionSet: selectionSet(),\n    };\n  }\n}\n\nfunction type(): ast.TypeNode {\n  let match: ast.NameNode | ast.TypeNode | undefined;\n  ignored();\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    idx++;\n    ignored();\n    const _type = type();\n    if (!_type || input.charCodeAt(idx++) !== 93 /*']'*/) throw error('ListType');\n    match = {\n      kind: 'ListType' as Kind.LIST_TYPE,\n      type: _type,\n    };\n  } else if ((match = name())) {\n    match = {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: match,\n    };\n  } else {\n    throw error('NamedType');\n  }\n\n  ignored();\n  if (input.charCodeAt(idx) === 33 /*'!'*/) {\n    idx++;\n    ignored();\n    return {\n      kind: 'NonNullType' as Kind.NON_NULL_TYPE,\n      type: match,\n    };\n  } else {\n    return match;\n  }\n}\n\nconst typeConditionRe = /on/y;\nfunction typeCondition(): ast.NamedTypeNode | undefined {\n  if (advance(typeConditionRe)) {\n    ignored();\n    const _name = name();\n    if (!_name) throw error('NamedType');\n    ignored();\n    return {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: _name,\n    };\n  }\n}\n\nconst fragmentSpreadRe = /\\.\\.\\./y;\n\nfunction fragmentSpread(): ast.FragmentSpreadNode | ast.InlineFragmentNode | undefined {\n  if (advance(fragmentSpreadRe)) {\n    ignored();\n    const _idx = idx;\n    let _name: ast.NameNode | undefined;\n    if ((_name = name()) && _name.value !== 'on') {\n      return {\n        kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n        name: _name,\n        directives: directives(false),\n      };\n    } else {\n      idx = _idx;\n      const _typeCondition = typeCondition();\n      const _directives = directives(false);\n      const _selectionSet = selectionSet();\n      if (!_selectionSet) throw error('InlineFragment');\n      return {\n        kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n        typeCondition: _typeCondition,\n        directives: _directives,\n        selectionSet: _selectionSet,\n      };\n    }\n  }\n}\n\nfunction selectionSet(): ast.SelectionSetNode | undefined {\n  let match: ast.SelectionNode | undefined;\n  ignored();\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    const selections: ast.SelectionNode[] = [];\n    while ((match = fragmentSpread() || field())) selections.push(match);\n    if (!selections.length || input.charCodeAt(idx++) !== 125 /*'}'*/) throw error('SelectionSet');\n    ignored();\n    return {\n      kind: 'SelectionSet' as Kind.SELECTION_SET,\n      selections,\n    };\n  }\n}\n\nfunction variableDefinitions(): ast.VariableDefinitionNode[] {\n  let match: string | undefined;\n  const vars: ast.VariableDefinitionNode[] = [];\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    idx++;\n    ignored();\n    while ((match = advance(variableRe))) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('VariableDefinition');\n      const _type = type();\n      let _defaultValue: ast.ValueNode | undefined;\n      if (input.charCodeAt(idx) === 61 /*'='*/) {\n        idx++;\n        ignored();\n        _defaultValue = value(true);\n        if (!_defaultValue) throw error('VariableDefinition');\n      }\n      ignored();\n      vars.push({\n        kind: 'VariableDefinition' as Kind.VARIABLE_DEFINITION,\n        variable: {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: {\n            kind: 'Name' as Kind.NAME,\n            value: match.slice(1),\n          },\n        },\n        type: _type,\n        defaultValue: _defaultValue as ast.ConstValueNode,\n        directives: directives(true),\n      });\n    }\n    if (input.charCodeAt(idx++) !== 41 /*')'*/) throw error('VariableDefinition');\n    ignored();\n  }\n  return vars;\n}\n\nconst fragmentDefinitionRe = /fragment/y;\nfunction fragmentDefinition(): ast.FragmentDefinitionNode | undefined {\n  if (advance(fragmentDefinitionRe)) {\n    ignored();\n    const _name = name();\n    if (!_name) throw error('FragmentDefinition');\n    ignored();\n    const _typeCondition = typeCondition();\n    if (!_typeCondition) throw error('FragmentDefinition');\n    const _directives = directives(false);\n    const _selectionSet = selectionSet();\n    if (!_selectionSet) throw error('FragmentDefinition');\n    return {\n      kind: 'FragmentDefinition' as Kind.FRAGMENT_DEFINITION,\n      name: _name,\n      typeCondition: _typeCondition,\n      directives: _directives,\n      selectionSet: _selectionSet,\n    };\n  }\n}\n\n// NOTE(Safari10 Quirk): This *might* need to be wrapped in a group, but worked without it too\nconst operationDefinitionRe = /(?:query|mutation|subscription)/y;\n\nfunction operationDefinition(): ast.OperationDefinitionNode | undefined {\n  let _operation: string | undefined;\n  let _name: ast.NameNode | undefined;\n  let _variableDefinitions: ast.VariableDefinitionNode[] = [];\n  let _directives: ast.DirectiveNode[] = [];\n  if ((_operation = advance(operationDefinitionRe))) {\n    ignored();\n    _name = name();\n    _variableDefinitions = variableDefinitions();\n    _directives = directives(false);\n  }\n  const _selectionSet = selectionSet();\n  if (_selectionSet) {\n    return {\n      kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n      operation: (_operation || 'query') as OperationTypeNode,\n      name: _name,\n      variableDefinitions: _variableDefinitions,\n      directives: _directives,\n      selectionSet: _selectionSet,\n    };\n  }\n}\n\nfunction document(): ast.DocumentNode {\n  let match: ast.ExecutableDefinitionNode | void;\n  ignored();\n  const definitions: ast.ExecutableDefinitionNode[] = [];\n  while ((match = fragmentDefinition() || operationDefinition())) definitions.push(match);\n  return {\n    kind: 'Document' as Kind.DOCUMENT,\n    definitions,\n  };\n}\n\ntype ParseOptions = {\n  [option: string]: any;\n};\n\nexport function parse(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.DocumentNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return document();\n}\n\nexport function parseValue(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.ValueNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  ignored();\n  const _value = value(false);\n  if (!_value) throw error('ValueNode');\n  return _value;\n}\n\nexport function parseType(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.TypeNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return type();\n}\n","import { ASTNode } from './ast';\n\nexport const BREAK = {};\n\nexport function visit<N extends ASTNode>(root: N, visitor: ASTVisitor): N;\nexport function visit<R>(root: ASTNode, visitor: ASTReducer<R>): R;\n\nexport function visit(node: ASTNode, visitor: ASTVisitor | ASTReducer<any>) {\n  const ancestors: Array<ASTNode | ReadonlyArray<ASTNode>> = [];\n  const path: Array<string | number> = [];\n\n  function traverse(\n    node: ASTNode,\n    key?: string | number | undefined,\n    parent?: ASTNode | ReadonlyArray<ASTNode> | undefined\n  ) {\n    let hasEdited = false;\n\n    const enter =\n      (visitor[node.kind] && visitor[node.kind].enter) ||\n      visitor[node.kind] ||\n      (visitor as EnterLeaveVisitor<ASTNode>).enter;\n    const resultEnter = enter && enter.call(visitor, node, key, parent, path, ancestors);\n    if (resultEnter === false) {\n      return node;\n    } else if (resultEnter === null) {\n      return null;\n    } else if (resultEnter === BREAK) {\n      throw BREAK;\n    } else if (resultEnter && typeof resultEnter.kind === 'string') {\n      hasEdited = resultEnter !== node;\n      node = resultEnter;\n    }\n\n    if (parent) ancestors.push(parent);\n\n    let result: any;\n    const copy = { ...node };\n    for (const nodeKey in node) {\n      path.push(nodeKey);\n      let value = node[nodeKey];\n      if (Array.isArray(value)) {\n        const newValue: any[] = [];\n        for (let index = 0; index < value.length; index++) {\n          if (value[index] != null && typeof value[index].kind === 'string') {\n            ancestors.push(node);\n            path.push(index);\n            result = traverse(value[index], index, value);\n            path.pop();\n            ancestors.pop();\n            if (result == null) {\n              hasEdited = true;\n            } else {\n              hasEdited = hasEdited || result !== value[index];\n              newValue.push(result);\n            }\n          }\n        }\n        value = newValue;\n      } else if (value != null && typeof value.kind === 'string') {\n        result = traverse(value, nodeKey, node);\n        if (result !== undefined) {\n          hasEdited = hasEdited || value !== result;\n          value = result;\n        }\n      }\n\n      path.pop();\n      if (hasEdited) copy[nodeKey] = value;\n    }\n\n    if (parent) ancestors.pop();\n    const leave =\n      (visitor[node.kind] && visitor[node.kind].leave) ||\n      (visitor as EnterLeaveVisitor<ASTNode>).leave;\n    const resultLeave = leave && leave.call(visitor, node, key, parent, path, ancestors);\n    if (resultLeave === BREAK) {\n      throw BREAK;\n    } else if (resultLeave !== undefined) {\n      return resultLeave;\n    } else if (resultEnter !== undefined) {\n      return hasEdited ? copy : resultEnter;\n    } else {\n      return hasEdited ? copy : node;\n    }\n  }\n\n  try {\n    const result = traverse(node);\n    return result !== undefined && result !== false ? result : node;\n  } catch (error) {\n    if (error !== BREAK) throw error;\n    return node;\n  }\n}\n\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: ASTVisitFn<NodeT> | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\nexport type ASTVisitFn<Node extends ASTNode> = (\n  node: Node,\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => any;\n\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => R;\n\ntype ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n  ? ReadonlyArray<R>\n  : R;\n","import { ASTNode } from './ast';\n\nexport function printString(string: string) {\n  return JSON.stringify(string);\n}\n\nexport function printBlockString(string: string) {\n  return '\"\"\"\\n' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nconst hasItems = <T>(array: ReadonlyArray<T> | undefined | null): array is ReadonlyArray<T> =>\n  !!(array && array.length);\n\nconst MAX_LINE_LENGTH = 80;\n\nconst nodes: {\n  [NodeT in ASTNode as NodeT['kind']]?: (node: NodeT) => string;\n} = {\n  OperationDefinition(node) {\n    if (\n      node.operation === 'query' &&\n      !node.name &&\n      !hasItems(node.variableDefinitions) &&\n      !hasItems(node.directives)\n    ) {\n      return nodes.SelectionSet!(node.selectionSet);\n    }\n    let out: string = node.operation;\n    if (node.name) out += ' ' + node.name.value;\n    if (hasItems(node.variableDefinitions)) {\n      if (!node.name) out += ' ';\n      out += '(' + node.variableDefinitions.map(nodes.VariableDefinition!).join(', ') + ')';\n    }\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + nodes.SelectionSet!(node.selectionSet);\n  },\n  VariableDefinition(node) {\n    let out = nodes.Variable!(node.variable) + ': ' + print(node.type);\n    if (node.defaultValue) out += ' = ' + print(node.defaultValue);\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out;\n  },\n  Field(node) {\n    let out = (node.alias ? node.alias.value + ': ' : '') + node.name.value;\n    if (hasItems(node.arguments)) {\n      const args = node.arguments.map(nodes.Argument!);\n      const argsLine = out + '(' + args.join(', ') + ')';\n      out =\n        argsLine.length > MAX_LINE_LENGTH\n          ? out + '(\\n  ' + args.join('\\n').replace(/\\n/g, '\\n  ') + '\\n)'\n          : argsLine;\n    }\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return node.selectionSet ? out + ' ' + nodes.SelectionSet!(node.selectionSet) : out;\n  },\n  StringValue(node) {\n    return node.block ? printBlockString(node.value) : printString(node.value);\n  },\n  BooleanValue(node) {\n    return '' + node.value;\n  },\n  NullValue(_node) {\n    return 'null';\n  },\n  IntValue(node) {\n    return node.value;\n  },\n  FloatValue(node) {\n    return node.value;\n  },\n  EnumValue(node) {\n    return node.value;\n  },\n  Name(node) {\n    return node.value;\n  },\n  Variable(node) {\n    return '$' + node.name.value;\n  },\n  ListValue(node) {\n    return '[' + node.values.map(print).join(', ') + ']';\n  },\n  ObjectValue(node) {\n    return '{' + node.fields.map(nodes.ObjectField!).join(', ') + '}';\n  },\n  ObjectField(node) {\n    return node.name.value + ': ' + print(node.value);\n  },\n  Document(node) {\n    return hasItems(node.definitions) ? node.definitions.map(print).join('\\n\\n') : '';\n  },\n  SelectionSet(node) {\n    return '{\\n  ' + node.selections.map(print).join('\\n').replace(/\\n/g, '\\n  ') + '\\n}';\n  },\n  Argument(node) {\n    return node.name.value + ': ' + print(node.value);\n  },\n  FragmentSpread(node) {\n    let out = '...' + node.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out;\n  },\n  InlineFragment(node) {\n    let out = '...';\n    if (node.typeCondition) out += ' on ' + node.typeCondition.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + print(node.selectionSet);\n  },\n  FragmentDefinition(node) {\n    let out = 'fragment ' + node.name.value;\n    out += ' on ' + node.typeCondition.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + print(node.selectionSet);\n  },\n  Directive(node) {\n    let out = '@' + node.name.value;\n    if (hasItems(node.arguments)) out += '(' + node.arguments.map(nodes.Argument!).join(', ') + ')';\n    return out;\n  },\n  NamedType(node) {\n    return node.name.value;\n  },\n  ListType(node) {\n    return '[' + print(node.type) + ']';\n  },\n  NonNullType(node) {\n    return print(node.type) + '!';\n  },\n};\n\nexport function print(node: ASTNode): string {\n  return nodes[node.kind] ? (nodes as any)[node.kind]!(node) : '';\n}\n","import { TypeNode, ValueNode } from './ast';\nimport { Maybe } from './types';\n\nexport function valueFromASTUntyped(\n  node: ValueNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  switch (node.kind) {\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'StringValue':\n    case 'EnumValue':\n    case 'BooleanValue':\n      return node.value;\n    case 'ListValue': {\n      const values: unknown[] = [];\n      for (const value of node.values) values.push(valueFromASTUntyped(value, variables));\n      return values;\n    }\n    case 'ObjectValue': {\n      const obj = Object.create(null);\n      for (const field of node.fields)\n        obj[field.name.value] = valueFromASTUntyped(field.value, variables);\n      return obj;\n    }\n    case 'Variable':\n      return variables && variables[node.name.value];\n  }\n}\n\nexport function valueFromTypeNode(\n  node: ValueNode,\n  type: TypeNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  if (node.kind === 'Variable') {\n    const variableName = node.name.value;\n    return variables ? valueFromTypeNode(variables[variableName], type, variables) : undefined;\n  } else if (type.kind === 'NonNullType') {\n    return node.kind !== 'NullValue' ? valueFromTypeNode(node, type, variables) : undefined;\n  } else if (node.kind === 'NullValue') {\n    return null;\n  } else if (type.kind === 'ListType') {\n    if (node.kind === 'ListValue') {\n      const values: unknown[] = [];\n      for (const value of node.values) {\n        const coerced = valueFromTypeNode(value, type.type, variables);\n        if (coerced === undefined) {\n          return undefined;\n        } else {\n          values.push(coerced);\n        }\n      }\n      return values;\n    }\n  } else if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Int':\n      case 'Float':\n      case 'String':\n      case 'Bool':\n        return type.name.value + 'Value' === node.kind\n          ? valueFromASTUntyped(node, variables)\n          : undefined;\n      default:\n        return valueFromASTUntyped(node, variables);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}